#define _CRT_SECURE_NO_WARNINGS
#include "transform.h"
#include <stdio.h>
#include <stdlib.h>
#pragma pack(2)
#include<time.h>
#include<math.h>
#include<float.h>
#include "readYUV.h"


int i,j,k;
int M,N;

float p1 = 0.4142135623;
float u1 = 0.3535533905;
float p2 = 0.3033466836;
float u2 = 0.5555702330;
float p3 = 0.3033466836;
float p4 = 0.0984914033;
float u3 = 0.1950903220;
float p5 = 0.0984914033;

float dct_scale[8]={0.353553390593274,0.353553390593274,0.541196100146197,0.500000000000000,0.707106781186547,0.500000000000000,0.461939766255643,0.707106781186547};      //dct系数
float idct_scale[8]={0.707106781186547,0.707106781186547,0.461939766255643,0.500000000000000,0.353553390593274,0.500000000000000,0.541196100146197,0.353553390593274};     //idct系数

float p_i_scale[8]={0.707106781186547,0.017967622283447,0.014718624813284,0.019611613513819,0.015004918433667,0.019611613513819,0.017243941592282,0.008983811141724};      //prefiltering正变换,idct合并系数
float ip_d_scale[8]={0.353553390593274,0.008983811141724,0.017243941592282,0.019611613513819,0.030009836867333,0.019611613513819,0.014718624813284,0.017967622283447};     //prefiltering逆变换,dct合并系数


//DCT系数
float d0 = 0.353553390593274;
float d1 = 0.353553390593274;
float d2 = 0.541196100146197;
float d3 = 0.500000000000000;
float d4 = 0.707106781186547;
float d5 = 0.500000000000000;
float d6 = 0.461939766255643;
float d7 = 0.707106781186547;

//IDCT系数
float id0 = 0.707106781186547;
float id1 = 0.707106781186547;
float id2 = 0.461939766255643;
float id3 = 0.500000000000000;
float id4 = 0.353553390593274;
float id5 = 0.500000000000000;
float id6 = 0.541196100146197;
float id7 = 0.353553390593274;

//prefiltering、IDCT合并系数
float pid0 = 0.707106781186547;
float pid1 = 0.017967622283447;
float pid2 = 0.014718624813284;
float pid3 = 0.019611613513819;
float pid4 = 0.015004918433667;
float pid5 = 0.019611613513819;
float pid6 = 0.017243941592282;
float pid7 = 0.008983811141724;

//i_prefiltering、DCT合并系数
float ipd0 = 0.353553390593274;
float ipd1 = 0.008983811141724;
float ipd2 = 0.017243941592282;
float ipd3 = 0.019611613513819;
float ipd4 = 0.030009836867333;
float ipd5 = 0.019611613513819;
float ipd6 = 0.014718624813284;
float ipd7 = 0.017967622283447;

//SCWP4 系数
float ip0=0.5;
float ip1=0.028246279558347;
float ip2=0.029411764705883;
float ip3=0.068192551196344;

float D0=0.5;
float D1=0.382683432365090;
float D2=0.5;
float D3=0.923879532511287;

//haar 系数
float s1=0.7071067812;
float s2=0.5;
float s3=0.3535533906;

//PTV系数
float s=0.696228215322139;

void DCT(float *x)
{
    float a[8];
    float b[8];
    a[0]=*x+*(x+7);
    a[1]=*(x+1)+*(x+6);
    a[2]=*(x+2)+*(x+5);
    a[3]=*(x+3)+*(x+4);
    a[4]=*(x+3)-*(x+4);
    a[5]=*(x+2)-*(x+5);
    a[6]=*(x+1)-*(x+6);
    a[7]=*x-*(x+7);

    b[0]=a[0]+a[3];
    b[3]=a[0]-a[3];

    b[4]=a[1]+a[2];
    b[2]=a[1]-a[2];

    *x=b[0]+b[4];
    x[4]=*x/2-b[4];

    *(x+6)=b[3]*p1-b[2];       //p1
    *(x+2)=b[3]-*(x+6)*u1;     //u1

    b[7]=a[7]-a[4]*p2;         //p2
    b[1]=a[4]+b[7]*u2;         //u2
    b[7]-=b[1]*p3;             //p3

    b[6]=a[6]-a[5]*p4;         //p4
    b[5]=a[5]+b[6]*u3;         //u3
    b[6]-=b[5]*p5;             //p5

    *(x+3)=b[7]-b[5];
    *(x+5)=b[1]-b[6];

    b[1]+=b[6];
    b[7]+=b[5];

    *(x+1)=b[7]+b[1];
    *(x+7)=*(x+1)/2-b[1];

}
void IDCT(float *x)
{
    float a[8];
    *(x+4)=*x*0.5-*(x+4);
    *x-=*(x+4);

    *(x+2)+=*(x+6)*u1;             //u1
    *(x+6)=*(x+2)*p1-*(x+6);       //p1

    *(a+4)=*(x+6)+*(x+4);
    *(a+6)=*(x+4)-*(x+6);

    *a=*x+*(x+2);
    *(a+2)=*x-*(x+2);

    *(x+7)=*(x+1)*0.5-*(x+7);
    *(x+1)-=*(x+7);

    *(a+7)=*(x+5)+*(x+7);
    *(a+5)=*(x+7)-*(x+5);
    *(a+3)=*(x+1)-*(x+3);
    *(a+1)=*(x+3)+*(x+1);

    *(a+5)+=*(a+3)*p5;              //p5
    *(a+3)-=*(a+5)*u3;              //u3
    *(a+5)+=*(a+3)*p4;              //p4

    *(a+1)+=*(a+7)*p3;              //p3
    *(a+7)-=*(a+1)*u2;              //u2
    *(a+1)+=*(a+7)*p2;              //p2

    *(x+4)=*(a+2)-*(a+7);
    *(x+3)=*(a+2)+*(a+7);
    *(x+5)=*(a+6)-*(a+3);
    *(x+2)=*(a+6)+*(a+3);
    *(x+6)=*(a+4)-*(a+5);
    *(x+1)=*(a+4)+*(a+5);
    *(x+7)=*a-*(a+1);
    *x=*a+*(a+1);
}
void pre(float *x,float *y)
{
  *(y)=*(x);
  *(y+1)=(-*(x+15)+32.0**(x+1));
  *(y+2)=(-*(x+14)+14.0**(x+2));
  *(y+3)=(-*(x+13)+8.0**(x+3));
  *(y+4)=(-*(x+12)+4.75**(x+4));
  *(y+5)=(-*(x+11)+3.0**(x+5));
  *(y+6)=(-*(x+10)+2.0**(x+6));
  *(y+7)=(-0.71484375**(x+9)+*(x+7));
  *(y+8)=*(x+8);
  *(y+9)=(*(x+9)+0.71484375**(x+7));
  *(y+10)=(2.0**(x+10)+*(x+6));
  *(y+11)=(3.0**(x+11)+*(x+5));
  *(y+12)=(4.75**(x+12)+*(x+4));
  *(y+13)=(8.0**(x+13)+*(x+3));
  *(y+14)=(14.0**(x+14)+*(x+2));
  *(y+15)=(32.0**(x+15)+*(x+1));
}
void pre_left_mirror(float *x,float *y)
{
    *(y)=*(x);
    *(y+1)=(*(x+1)+0.71484375**(x+1));
    *(y+2)=(2.0**(x+2)+*(x+2));
    *(y+3)=(3.0**(x+3)+*(x+3));
    *(y+4)=(4.75**(x+4)+*(x+4));
    *(y+5)=(8.0**(x+5)+*(x+5));
    *(y+6)=(14.0**(x+6)+*(x+6));
    *(y+7)=(32.0**(x+7)+*(x+7));
}
void pre_right_mirror(float *x,float *y)
{
    *(y)=*(x);
    *(y+1)=(-*(x+1)+32.0**(x+1));
    *(y+2)=(-*(x+2)+14.0**(x+2));
    *(y+3)=(-*(x+3)+8.0**(x+3));
    *(y+4)=(-*(x+4)+4.75**(x+4));
    *(y+5)=(-*(x+5)+3.0**(x+5));
    *(y+6)=(-*(x+6)+2.0**(x+6));
    *(y+7)=(-0.71484375**(x+7)+*(x+7));
}
void EVEN_SCWP8_method2(float *x,int N)
{
    int l;
	float *a = (float*)malloc(sizeof(float)*N);
	float *b = (float*)malloc(sizeof(float)*N);
    //float a[N];
    //float b[N];
    pre_left_mirror(x,a);
    pre_right_mirror(x+N-8,a+N-8);
    for(l=8;l<N-8;l+=16)
    {
        pre(x+l,a+l);
    }
    for(l=0;l<N;l+=16)
    {
        pre(a+l,b+l);
    }
    for(l=8;l<N-8;l++)
    {
        *(b+l)*=p_i_scale[l%8];
    }
    DCT(x);
    for(l=8;l<N-8;l+=8)
    {
        IDCT(b+l);
    }
    DCT(x+N-8);
    for(l=0;l<8;l++)
    {
        *(x+l)*=dct_scale[l%8];
    }
    for(l=N-8;l<N;l++)
    {
        *(x+l)*=dct_scale[l%8];
    }
    for(l=8;l<N-8;l++)
    {
        *(x+l)=*(b+l);
    }
	free(a); free(b);
}
void ODD_SCWP8_method2(float *x,int N)
{
    int l;
	float *a = (float*)malloc(sizeof(float)*N);
	float *b = (float*)malloc(sizeof(float)*N);
    //float a[N];
    //float b[N];
    pre_left_mirror(x,a);
    for(l=8;l<N;l+=16)
    {
        pre(x+l,a+l);
    }
    for(l=0;l<N-8;l+=16)
    {
        pre(a+l,b+l);
    }
    for(l=8;l<N-8;l++)
    {
        *(b+l)*=p_i_scale[l%8];
    }
    DCT(x);
    for(l=8;l<N-8;l+=8)
    {
        IDCT(b+l);
    }
    DCT(x+N-8);
    for(l=0;l<8;l++)
    {
        *(x+l)*=dct_scale[l%8];
    }
    for(l=N-8;l<N;l++)
    {
        *(x+l)*=dct_scale[l%8];
    }
    for(l=8;l<N-8;l++)
    {
        *(x+l)=*(b+l);
    }
}
void keep(float *x,float *y)
{
  *(y)=*(x);
  *(y+1)=*(x+1);
  *(y+2)=*(x+2);
  *(y+3)=*(x+3);
  *(y+4)=*(x+4);
  *(y+5)=*(x+5);
  *(y+6)=*(x+6);
  *(y+7)=*(x+7);
}
void i_prefiltering(float *x,float *y)
{
  *(y)=*(x);
  *(y+1)=(*(x+15)+32.0**(x+1));
  *(y+2)=(*(x+14)+14.0**(x+2));
  *(y+3)=(*(x+13)+8.0**(x+3));
  *(y+4)=(*(x+12)+4.75**(x+4));
  *(y+5)=(*(x+11)+3.0**(x+5));
  *(y+6)=(*(x+10)+2.0**(x+6));
  *(y+7)=(0.71484375**(x+9)+*(x+7));
  *(y+8)=*(x+8);
  *(y+9)=(*(x+9)-0.71484375**(x+7));
  *(y+10)=(2.0**(x+10)-*(x+6));
  *(y+11)=(3.0**(x+11)-*(x+5));
  *(y+12)=(4.75**(x+12)-*(x+4));
  *(y+13)=(8.0**(x+13)-*(x+3));
  *(y+14)=(14.0**(x+14)-*(x+2));
  *(y+15)=(32.0**(x+15)-*(x+1));
}
void ipre_right(float *x,float *y)
{
    *(y)=*(x);
    *(y+1)=(*(x+15)+*(x+1)/0.000975609756097)/32.0;
    *(y+2)=(*(x+14)+*(x+2)/0.005076142131980)/14.0;
    *(y+3)=(*(x+13)+*(x+3)/0.015384615384615)/8.0;
    *(y+4)=(*(x+12)+*(x+4)/0.042440318302387)/4.75;
    *(y+5)=(*(x+11)+*(x+5)/0.1)/3.0;
    *(y+6)=(*(x+10)+*(x+6)/0.2)/2.0;
    *(y+7)=*(x+7)/0.661812673567281+0.71484375**(x+9);
}
void ipre_left_mirror(float *x,float *y)
{
    *(y+8)=*(x+8);
    *(y+9)=(*(x+9)/0.000645670901041-0.71484375*(32.0**(x+7)+*(x+7)))*0.000975609756098;             //s1*c7*s1*c7,s1*s1
    *(y+10)=(*(x+10)/0.001015228426396-(14.0**(x+6)+*(x+6)))/2*0.005076142131980;
    *(y+11)=(*(x+11)/0.001538461538462-(8.0**(x+5)+*(x+5)))/3.0*0.015384615384615;
    *(y+12)=(*(x+12)/0.001801180617608-(4.75**(x+4)+*(x+4)))/4.75*0.042440318302387;
    *(y+13)=(*(x+13)/0.001538461538462-(3.0**(x+3)+*(x+3)))/8*0.1;
    *(y+14)=(*(x+14)/0.001015228426396-(2.0**(x+2)+*(x+2)))/14*0.2;                                  //s2*s6*s2*s6,s6*s6
    *(y+15)=(*(x+15)/0.000645670901041-(*(x+1)+0.71484375**(x+1)))/32*0.661812673567281;
}
void ipre_right_mirror(float *x,float *y)
{
    *(y)=*(x);
    *(y+1)=(*(x+1)/0.000645670901041+(-0.71484375**(x+15)+*(x+15)))/32.0*0.661812673567281;
    *(y+2)=(*(x+2)/0.001015228426396+(-*(x+14)+2.0**(x+14)))/14.0*0.2;                                //s2*s6*s2*s6,s6*s6
    *(y+3)=(*(x+3)/0.001538461538462+(-*(x+13)+3.0**(x+13)))/8.0*0.1;
    *(y+4)=(*(x+4)/0.001801180617608+(-*(x+12)+4.75**(x+12)))/4.75*0.042440318302387;
    *(y+5)=(*(x+5)/0.001538461538462+(-*(x+11)+8.0**(x+11)))/3.0*0.015384615384615;
    *(y+6)=(*(x+6)/0.001015228426396+(-*(x+10)+14.0**(x+10)))/2.0*0.005076142131980;
    *(y+7)=(*(x+7)/0.000645670901041+0.71484375*(-*(x+9)+32.0**(x+9)))*0.000975609756098;             //s1*c7*s1*c7,s1*s1
}
void ODD_ISCWP8_method2(float *x,int N)
{
    int l;
	float *a = (float*)malloc(sizeof(float)*N);
	float *b = (float*)malloc(sizeof(float)*N);
    //float a[N];
    //float b[N];
    for(l=0;l<8;l++)
    {
        *(x+l)*=idct_scale[l%8];
    }
    for(l=N-8;l<N;l++)
    {
        *(x+l)*=idct_scale[l%8];
    }
    IDCT(x);
    for(l=8;l<N-8;l+=8)
    {
        DCT(x+l);
    }
    IDCT(x+N-8);
    for(l=8;l<N-8;l++)
    {
        *(x+l)*=ip_d_scale[l%8];
    }
    ipre_left_mirror(x,a);
    for(l=16;l<N-16;l+=16)
    {
        i_prefiltering(x+l,a+l);
    }
    for(l=8;l<N-16;l+=16)
    {
        i_prefiltering(a+l,x+l);
    }
    keep(x+N-8,a+N-8);
    ipre_right(a+N-16,x+N-16);

	free(a); free(b);
}
void EVEN_ISCWP8_method2(float *x,int N)
{
    int l;
	float *a = (float*)malloc(sizeof(float)*N);
	float *b = (float*)malloc(sizeof(float)*N);
    //float a[N];
    //float b[N];
    for(l=0;l<8;l++)
    {
        *(x+l)*=idct_scale[l%8];
    }
    for(l=N-8;l<N;l++)
    {
        *(x+l)*=idct_scale[l%8];
    }
    IDCT(x);
    for(l=8;l<N-8;l+=8)
    {
        DCT(x+l);
    }
    IDCT(x+N-8);
    for(l=8;l<N-8;l++)
    {
        *(x+l)*=ip_d_scale[l%8];
    }
    ipre_left_mirror(x,a);
    ipre_right_mirror(x+N-16,a+N-16);

    for(l=16;l<N-16;l+=16)
    {
        i_prefiltering(x+l,a+l);
    }
    for(l=8;l<N-8;l+=16)
    {
        i_prefiltering(a+l,x+l);
    }
	free(a); free(b);
}
void Dct(float *x)
{
    float a[8];
    float b[8];
    float c;
    a[0]=x[0]+x[7];
    a[1]=x[1]+x[6];
    a[2]=x[2]+x[5];
    a[3]=x[3]+x[4];
    a[4]=x[3]-x[4];
    a[5]=x[2]-x[5];
    a[6]=x[1]-x[6];
    a[7]=x[0]-x[7];

    c=a[0]+a[3]+a[1]+a[2];
    x[4]=(c*0.5-a[1]-a[2])*d4;
    x[0]=c*d0;

    c=(a[0]-a[3])*p1-a[1]+a[2];
    x[2]=(a[0]-a[3]-c*u1)*d2;
    x[6]=c*d6;

    b[7]=a[7]-a[4]*p2;
    b[1]=a[4]+b[7]*u2;
    b[7]-=b[1]*p3;

    b[6]=a[6]-a[5]*p4;
    b[5]=a[5]+b[6]*u3;
    b[6]-=b[5]*p5;

    x[3]=(b[7]-b[5])*d3;
    x[5]=(b[1]-b[6])*d5;

    c=b[7]+b[5]+b[1]+b[6];
    x[7]=(c*0.5-b[1]-b[6])*d7;
    x[1]=c*d1;
}
void Dct_3(float *x)
{
    float a[8];
    float b[8];
    float c;
    a[0]=x[0]+x[7];
    a[1]=x[1]+x[6];
    a[2]=x[2]+x[5];
    a[3]=x[3]+x[4];
    a[4]=x[3]-x[4];
    a[5]=x[2]-x[5];
    a[6]=x[1]-x[6];
    a[7]=x[0]-x[7];

    c=a[0]+a[3]+a[1]+a[2];
    x[4]=(c*0.5-a[1]-a[2])*ipd4;
    x[0]=c*ipd0;

    c=(a[0]-a[3])*p1-a[1]+a[2];
    x[2]=(a[0]-a[3]-c*u1)*ipd2;
    x[6]=c*ipd6;

    b[7]=a[7]-a[4]*p2;
    b[1]=a[4]+b[7]*u2;
    b[7]-=b[1]*p3;

    b[6]=a[6]-a[5]*p4;
    b[5]=a[5]+b[6]*u3;
    b[6]-=b[5]*p5;

    x[3]=(b[7]-b[5])*ipd3;
    x[5]=(b[1]-b[6])*ipd5;

    c=b[7]+b[5]+b[1]+b[6];
    x[7]=(c*0.5-b[1]-b[6])*ipd7;
    x[1]=c*ipd1;
}
void Idct(float *x,float *y)
{
    float a[8];
    float b[8];
    b[4]=x[0]*0.5-x[4];
    b[0]=x[0]-b[4];

    b[2]=x[2]+x[6]*u1;
    b[6]=b[2]*p1-x[6];

    a[4]=b[6]+b[4];
    a[6]=b[4]-b[6];

    a[0]=b[0]+b[2];
    a[2]=b[0]-b[2];

    b[7]=x[1]*0.5-x[7];
    b[1]=x[1]-b[7];

    a[7]=x[5]+b[7];
    a[5]=b[7]-x[5];
    a[3]=b[1]-x[3];
    a[1]=x[3]+b[1];

    a[5]+=a[3]*p5;
    a[3]-=a[5]*u3;
    a[5]+=a[3]*p4;
    a[1]+=a[7]*p3;
    a[7]-=a[1]*u2;
    a[1]+=a[7]*p2;

    y[4]=a[2]-a[7];
    y[3]=a[2]+a[7];
    y[5]=a[6]-a[3];
    y[2]=a[6]+a[3];
    y[6]=a[4]-a[5];
    y[1]=a[4]+a[5];
    y[7]=a[0]-a[1];
    y[0]=a[0]+a[1];
}
void Pre(float *x,float *y)
{
    y[0]=-x[15]+32.0*x[1];
    y[1]=-x[14]+14.0*x[2];
    y[2]=-x[13]+8.0*x[3];
    y[3]=-x[12]+4.75*x[4];
    y[4]=-x[11]+3.0*x[5];
    y[5]=-x[10]+2.0*x[6];
    y[6]=-0.71484375*x[9]+x[7];
    y[7]=x[9]+0.71484375*x[7];
    y[8]=2.0*x[10]+x[6];
    y[9]=3.0*x[11]+x[5];
    y[10]=4.75*x[12]+x[4];
    y[11]=8.0*x[13]+x[3];
    y[12]=14.0*x[14]+x[2];
    y[13]=32.0*x[15]+x[1];
}
void Pre_lap(float *x,float *y,float *a,float b0,float b1)
{
    a[0]=b0*pid0;
    a[1]=(-y[6]+32.0*x[7])*pid1;
    a[2]=(-y[5]+14.0*x[8])*pid2;
    a[3]=(-y[4]+8.0*x[9])*pid3;
    a[4]=(-y[3]+4.75*x[10])*pid4;
    a[5]=(-y[2]+3.0*x[11])*pid5;
    a[6]=(-y[1]+2.0*x[12])*pid6;
    a[7]=(-0.71484375*y[0]+x[13])*pid7;
    a[8]=b1*pid0;
    a[9]=(y[0]+0.71484375*x[13])*pid1;
    a[10]=(2.0*y[1]+x[12])*pid2;
    a[11]=(3.0*y[2]+x[11])*pid3;
    a[12]=(4.75*y[3]+x[10])*pid4;
    a[13]=(8.0*y[4]+x[9])*pid5;
    a[14]=(14.0*y[5]+x[8])*pid6;
    a[15]=(32.0*y[6]+x[7])*pid7;
}
void Pre_left_mirror(float *x,float *y)
{
    *(y)=1.71484375**(x+1);
    *(y+1)=3.0**(x+2);
    *(y+2)=4.0**(x+3);
    *(y+3)=5.75**(x+4);
    *(y+4)=9.0**(x+5);
    *(y+5)=15.0**(x+6);
    *(y+6)=33.0**(x+7);
}
//
void Pre_right_mirror(float *x,float *y)
{
    *(y)=31.0**(x+1);
    *(y+1)=13.0**(x+2);
    *(y+2)=7.0**(x+3);
    *(y+3)=3.75**(x+4);
    *(y+4)=2.0**(x+5);
    *(y+5)=*(x+6);
    *(y+6)=0.28515625**(x+7);
}
void Even_row_scwp2(float *x,int N)
{
    int k;
    float a1[14];
    float a2[14];
    float a3[16];
    float c;
    Pre_left_mirror(x,a1+7);
    Pre(x+8,a2);
    Pre_lap(a1,a2,a3,*x,*(x+8));
    Dct(x);
    Idct(a3+8,x+8);
    for(k=24;k<N-8;k+=16)
    {
        if(k%32==24)
        {
            Pre(x+k,a1);
            Pre_lap(a2,a1,a3,*(x+k-8),*(x+k));
            Idct(a3,x+k-8);
            Idct(a3+8,x+k);
        }
        else  //k%32!=24
        {
            Pre(x+k,a2);
            Pre_lap(a1,a2,a3,*(x+k-8),*(x+k));
            Idct(a3,x+k-8);
            Idct(a3+8,x+k);
        }
    }
    if(N%32==0)
    {
        Pre_right_mirror(x+N-8,a1);
        Pre_lap(a2,a1,a3,*(x+N-16),*(x+N-8));
    }
    else  //N%32!=32
    {
        Pre_right_mirror(x+N-8,a2);
        Pre_lap(a1,a2,a3,*(x+N-16),*(x+N-8));
    }
    Idct(a3,x+N-16);
    Dct(x+N-8);
}
void Odd_row_scwp2(float *x,int N)
{
    int k;
    float a1[14];
    float a2[14];
    float a3[16];
    Pre_left_mirror(x,a1+7);
    Pre(x+8,a2);
    Pre_lap(a1,a2,a3,*x,*(x+8));
    Dct(x);
    Idct(a3+8,x+8);
    for(k=24;k<N;k+=16)
    {
        if(k%32==24)
        {
            Pre(x+k,a1);
            Pre_lap(a2,a1,a3,*(x+k-8),*(x+k));
            Idct(a3,x+k-8);
            Idct(a3+8,x+k);
        }
        else  //k%32!=24
        {
            Pre(x+k,a2);
            Pre_lap(a1,a2,a3,*(x+k-8),*(x+k));
            Idct(a3,x+k-8);
            Idct(a3+8,x+k);
        }
    }
    Dct(x+N-8);
}
void Idct_2(float *x)
{
    float a[8];
    float b[8];
    *(b+4)=x[0]*id0*0.5-x[4]*id4;
    *b=x[0]*id0-*(b+4);
    *(b+2)=x[2]*id2+x[6]*id6*u1;   //u1
    *(b+6)=*(b+2)*p1-x[6]*id6;     //p1
    a[4]=b[6]+b[4];
    a[6]=b[4]-b[6];
    a[0]=b[0]+b[2];
    a[2]=b[0]-b[2];
    *(b+7)=x[1]*id1*0.5-x[7]*id7;
    *(b+1)=x[1]*id1-*(b+7);
    a[7]=x[5]*id5+b[7];
    a[5]=b[7]-x[5]*id5;
    a[3]=b[1]-x[3]*id3;
    a[1]=x[3]*id3+b[1];
    a[5]+=a[3]*p5;              //p5
    a[3]-=a[5]*u3;              //u3
    a[5]+=a[3]*p4;              //p4
    a[1]+=a[7]*p3;              //p3
    a[7]-=a[1]*u2;              //u2
    a[1]+=a[7]*p2;              //p2
    x[4]=a[2]-a[7];
    x[3]=a[2]+a[7];
    x[5]=a[6]-a[3];
    x[2]=a[6]+a[3];
    x[6]=a[4]-a[5];
    x[1]=a[4]+a[5];
    x[7]=a[0]-a[1];
    x[0]=a[0]+a[1];
}
void Dct_2(float *x,float *y)
{
    float a[8];
    float b[8];
    float c;
    a[0]=*x+*(x+7);
    a[1]=*(x+1)+*(x+6);
    a[2]=*(x+2)+*(x+5);
    a[3]=*(x+3)+*(x+4);
    a[4]=*(x+3)-*(x+4);
    a[5]=*(x+2)-*(x+5);
    a[6]=*(x+1)-*(x+6);
    a[7]=*x-*(x+7);

    b[0]=a[0]+a[3];
    b[3]=a[0]-a[3];

    b[4]=a[1]+a[2];
    b[2]=a[1]-a[2];

    c=b[0]+b[4];
    y[4]=(c/2-b[4])*ipd4;
    *y=c*ipd0;

    c=b[3]*p1-b[2];            //p1
    *(y+2)=(b[3]-c*u1)*ipd2;     //u1
    *(y+6)=c*ipd6;

    b[7]=a[7]-a[4]*p2;         //p2
    b[1]=a[4]+b[7]*u2;         //u2
    b[7]-=b[1]*p3;             //p3

    b[6]=a[6]-a[5]*p4;         //p4
    b[5]=a[5]+b[6]*u3;         //u3
    b[6]-=b[5]*p5;             //p5

    *(y+3)=(b[7]-b[5])*ipd3;
    *(y+5)=(b[1]-b[6])*ipd5;

    b[1]+=b[6];
    b[7]+=b[5];

    c=b[7]+b[1];
    *(y+7)=(c/2-b[1])*ipd7;
    *(y+1)=c*ipd1;
}
void Ipre_right(float *x,float *y)
{
    *(y)=(*(x+15)+*(x+1)/0.000975609756097)/32.0;
    *(y+1)=(*(x+14)+*(x+2)/0.005076142131980)/14.0;
    *(y+2)=(*(x+13)+*(x+3)/0.015384615384615)/8.0;
    *(y+3)=(*(x+12)+*(x+4)/0.042440318302387)/4.75;
    *(y+4)=(*(x+11)+*(x+5)/0.1)/3.0;
    *(y+5)=(*(x+10)+*(x+6)/0.2)/2.0;
    *(y+6)=*(x+7)/0.661812673567281+0.71484375**(x+9);
}
void Ipre_left_mirror(float *x,float *y)
{
    *(y+7)=(*(x+9)/0.000645670901041-0.71484375*(32.0**(x+7)+*(x+7)))*0.000975609756098;             //s1*c7*s1*c7,s1*s1
    *(y+8)=(*(x+10)/0.001015228426396-(14.0**(x+6)+*(x+6)))/2*0.005076142131980;
    *(y+9)=(*(x+11)/0.001538461538462-(8.0**(x+5)+*(x+5)))/3.0*0.015384615384615;
    *(y+10)=(*(x+12)/0.001801180617608-(4.75**(x+4)+*(x+4)))/4.75*0.042440318302387;
    *(y+11)=(*(x+13)/0.001538461538462-(3.0**(x+3)+*(x+3)))/8*0.1;
    *(y+12)=(*(x+14)/0.001015228426396-(2.0**(x+2)+*(x+2)))/14*0.2;                                  //s2*s6*s2*s6,s6*s6
    *(y+13)=(*(x+15)/0.000645670901041-(*(x+1)+0.71484375**(x+1)))/32*0.661812673567281;
}
void Ipre_right_mirror(float *x,float *y)
{
    *(y)=(*(x+1)/0.000645670901041+(-0.71484375**(x+15)+*(x+15)))/32.0*0.661812673567281;
    *(y+1)=(*(x+2)/0.001015228426396+(-*(x+14)+2.0**(x+14)))/14.0*0.2;                                //s2*s6*s2*s6,s6*s6
    *(y+2)=(*(x+3)/0.001538461538462+(-*(x+13)+3.0**(x+13)))/8.0*0.1;
    *(y+3)=(*(x+4)/0.001801180617608+(-*(x+12)+4.75**(x+12)))/4.75*0.042440318302387;
    *(y+4)=(*(x+5)/0.001538461538462+(-*(x+11)+8.0**(x+11)))/3.0*0.015384615384615;
    *(y+5)=(*(x+6)/0.001015228426396+(-*(x+10)+14.0**(x+10)))/2.0*0.005076142131980;
    *(y+6)=(*(x+7)/0.000645670901041+0.71484375*(-*(x+9)+32.0**(x+9)))*0.000975609756098;             //s1*c7*s1*c7,s1*s1
}
void Ipre(float *x,float *y,float *a)
{
    *(a)=(*(y+7)+32.0**(x+1));
    *(a+1)=(*(y+6)+14.0**(x+2));
    *(a+2)=(*(y+5)+8.0**(x+3));
    *(a+3)=(*(y+4)+4.75**(x+4));
    *(a+4)=(*(y+3)+3.0**(x+5));
    *(a+5)=(*(y+2)+2.0**(x+6));
    *(a+6)=(0.71484375**(y+1)+*(x+7));
    *(a+7)=(*(y+1)-0.71484375**(x+7));
    *(a+8)=(2.0**(y+2)-*(x+6));
    *(a+9)=(3.0**(y+3)-*(x+5));
    *(a+10)=(4.75**(y+4)-*(x+4));
    *(a+11)=(8.0**(y+5)-*(x+3));
    *(a+12)=(14.0**(y+6)-*(x+2));
    *(a+13)=(32.0**(y+7)-*(x+1));
}
void Ipre_2(float *x,float *y,float *a,float b0,float b1)
{
    *(a)=b0;
    *(a+1)=(*(y+6)+32.0**(x+7));
    *(a+2)=(*(y+5)+14.0**(x+8));
    *(a+3)=(*(y+4)+8.0**(x+9));
    *(a+4)=(*(y+3)+4.75**(x+10));
    *(a+5)=(*(y+2)+3.0**(x+11));
    *(a+6)=(*(y+1)+2.0**(x+12));
    *(a+7)=(0.71484375**(y)+*(x+13));
    *(a+8)=b1;
    *(a+9)=(*(y)-0.71484375**(x+13));
    *(a+10)=(2.0**(y+1)-*(x+12));
    *(a+11)=(3.0**(y+2)-*(x+11));
    *(a+12)=(4.75**(y+3)-*(x+10));
    *(a+13)=(8.0**(y+4)-*(x+9));
    *(a+14)=(14.0**(y+5)-*(x+8));
    *(a+15)=(32.0**(y+6)-*(x+7));
}
void IPre_Right(float *a,float *x,float a0)
{
    *(x)=a0;
    *(x+1)=(*(x+15)+*(a)/0.000975609756097)/32.0;
    *(x+2)=(*(x+14)+*(a+1)/0.005076142131980)/14.0;
    *(x+3)=(*(x+13)+*(a+2)/0.015384615384615)/8.0;
    *(x+4)=(*(x+12)+*(a+3)/0.042440318302387)/4.75;
    *(x+5)=(*(x+11)+*(a+4)/0.1)/3.0;
    *(x+6)=(*(x+10)+*(a+5)/0.2)/2.0;
    *(x+7)=*(a+6)/0.661812673567281+0.71484375**(x+9);
}
void Even_row_iscwp2(float *x,int N)
{
    int k;
    float a1[8];
    float a2[8];
    float a3[14];
    float a4[14];
    float c;
    Idct_2(x);
    Dct_3(x+8);
    Ipre_left_mirror(x,a3);
    Dct_2(x+16,a1);
    Dct_2(x+24,a2);
    Ipre(a1,a2,a4);
    Ipre_2(a3,a4,x+8,*(x+8),*a1);
    for(k=32;k<N-16;k+=16)
    {
        if(k%32==0)
        {
            c=*a2;
            Dct_2(x+k,a1);
            Dct_2(x+k+8,a2);
            Ipre(a1,a2,a3);
            Ipre_2(a4,a3,x+k-8,c,*a1);

        }
        else  //k%32!=0
        {
            c=*a2;
            Dct_2(x+k,a1);
            Dct_2(x+k+8,a2);
            Ipre(a1,a2,a4);
            Ipre_2(a3,a4,x+k-8,c,*a1);
        }
    }
    Dct_3(x+N-16);
    Idct_2(x+N-8);
    if(N%32==0)
    {
        Ipre_right_mirror(x+N-16,a4);
        Ipre_2(a3,a4,x+N-24,*a2,*(x+N-16));
    }
    else  //N%32!=0
    {
        Ipre_right_mirror(x+N-16,a3);
        Ipre_2(a4,a3,x+N-24,*a2,*(x+N-16));
    }
}
void Odd_row_iscwp2(float *x,int N)
{
    int k;
    float a1[8];
    float a2[8];
    float a3[14];
    float a4[14];
    float c;
    Idct_2(x);
    Dct_3(x+8);
    Ipre_left_mirror(x,a3);
    Dct_2(x+16,a1);
    Dct_2(x+24,a2);
    Ipre(a1,a2,a4);
    Ipre_2(a3,a4,x+8,*(x+8),*a1);
    for(k=32;k<N-16;k+=16)
    {
        if(k%32==0)
        {
            c=*a2;
            Dct_2(x+k,a1);
            Dct_2(x+k+8,a2);
            Ipre(a1,a2,a3);
            Ipre_2(a4,a3,x+k-8,c,*a1);

        }
        else  //k%32!=0
        {
            c=*a2;
            Dct_2(x+k,a1);
            Dct_2(x+k+8,a2);
            Ipre(a1,a2,a4);
            Ipre_2(a3,a4,x+k-8,c,*a1);
        }
    }
    Idct_2(x+N-8);
    if(N%32==8)
    {
        IPre_Right(a4+7,x+N-16,*a2);
    }
    else  //N%32!=0
    {
        IPre_Right(a3+7,x+N-16,*a2);
    }
}

void EVEN_SCWP_column_Method2(float ***x,int M,int N)
{
    //float a1[N][7];
	float **a1 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a1[i] = (float*)malloc(sizeof(float)* 7);
    float a2[7];
    float a3[16];
    float a[8];
    float b[8];
    float c;
    for(i=0;i<96;i++)
    {
        for(k=0;k<N;k++)
        {
            //pre mirror up
            a1[k][0]=1.71484375*x[i][1][k];
            a1[k][1]=3.0*x[i][2][k];
            a1[k][2]=4.0*x[i][3][k];
            a1[k][3]=5.75*x[i][4][k];
            a1[k][4]=9.0*x[i][5][k];
            a1[k][5]=15.0*x[i][6][k];
            a1[k][6]=33.0*x[i][7][k];
            //pre
            a2[0]=-x[i][23][k]+32.0*x[i][9][k];
            a2[1]=-x[i][22][k]+14.0*x[i][10][k];
            a2[2]=-x[i][21][k]+8.0*x[i][11][k];
            a2[3]=-x[i][20][k]+4.75*x[i][12][k];
            a2[4]=(-x[i][19][k]+3.0*x[i][13][k]);
            a2[5]=(-x[i][18][k]+2.0*x[i][14][k]);
            a2[6]=(-0.71484375*x[i][17][k]+x[i][15][k]);
            //pre
            *(a3+8)=x[i][8][k]*pid0;
            *(a3+9)=(a2[0]+0.71484375*a1[k][6])*pid1;
            *(a3+10)=(2.0*a2[1]+a1[k][5])*pid2;
            *(a3+11)=(3.0*a2[2]+a1[k][4])*pid3;
            *(a3+12)=(4.75*a2[3]+a1[k][3])*pid4;
            *(a3+13)=(8.0*a2[4]+a1[k][2])*pid5;
            *(a3+14)=(14.0*a2[5]+a1[k][1])*pid6;
            *(a3+15)=(32.0*a2[6]+a1[k][0])*pid7;
            //pre
            a1[k][0]=(x[i][17][k]+0.71484375*x[i][15][k]);
            a1[k][1]=(2.0*x[i][18][k]+x[i][14][k]);
            a1[k][2]=(3.0*x[i][19][k]+x[i][13][k]);
            a1[k][3]=(4.75*x[i][20][k]+x[i][12][k]);
            a1[k][4]=(8.0*x[i][21][k]+x[i][11][k]);
            a1[k][5]=(14.0*x[i][22][k]+x[i][10][k]);
            a1[k][6]=(32.0*x[i][23][k]+x[i][9][k]);
            //dct
            a[0]=x[i][0][k]+x[i][7][k];
            a[1]=x[i][1][k]+x[i][6][k];
            a[2]=x[i][2][k]+x[i][5][k];
            a[3]=x[i][3][k]+x[i][4][k];
            a[4]=x[i][3][k]-x[i][4][k];
            a[5]=x[i][2][k]-x[i][5][k];
            a[6]=x[i][1][k]-x[i][6][k];
            a[7]=x[i][0][k]-x[i][7][k];

            c=a[0]+a[3]+a[1]+a[2];
            x[i][4][k]=(c*0.5-a[1]-a[2])*d4;
            x[i][0][k]=c*d0;

            c=(a[0]-a[3])*p1-a[1]+a[2];   //p1
            x[i][2][k]=(a[0]-a[3]-c*u1)*d2;      //u1
            x[i][6][k]=c*d6;

            b[7]=a[7]-a[4]*p2;        //p2
            b[1]=a[4]+b[7]*u2;        //u2
            b[7]-=b[1]*p3;            //p3

            b[6]=a[6]-a[5]*p4;        //p4
            b[5]=a[5]+b[6]*u3;        //u3
            b[6]-=b[5]*p5;            //p5

            x[i][3][k]=(b[7]-b[5])*d3;
            x[i][5][k]=(b[1]-b[6])*d5;

            c=b[7]+b[5]+b[1]+b[6];
            x[i][7][k]=(c*0.5-b[1]-b[6])*d7;
            x[i][1][k]=c*d1;
            //idct
            b[4]=a3[8]*0.5-a3[12];
            b[0]=a3[8]-b[4];
            b[2]=a3[10]+a3[14]*u1;     //u1
            b[6]=b[2]*p1-a3[14];       //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            b[7]=a3[9]*0.5-a3[15];
            b[1]=a3[9]-b[7];
            a[7]=a3[13]+b[7];
            a[5]=b[7]-a3[13];
            a[3]=b[1]-a3[11];
            a[1]=a3[11]+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][12][k]=a[2]-a[7];
            x[i][11][k]=a[2]+a[7];
            x[i][13][k]=a[6]-a[3];
            x[i][10][k]=a[6]+a[3];
            x[i][14][k]=a[4]-a[5];
            x[i][9][k]=a[4]+a[5];
            x[i][15][k]=a[0]-a[1];
            x[i][8][k]=a[0]+a[1];
        }
        for(j=24;j<M-16;j+=16)
        {
            for(k=0;k<N;k++)
            {
                //pre
                a2[0]=-x[i][j+15][k]+32.0*x[i][j+1][k];
                a2[1]=-x[i][j+14][k]+14.0*x[i][j+2][k];
                a2[2]=-x[i][j+13][k]+8.0*x[i][j+3][k];
                a2[3]=-x[i][j+12][k]+4.75*x[i][j+4][k];
                a2[4]=-x[i][j+11][k]+3.0*x[i][j+5][k];
                a2[5]=-x[i][j+10][k]+2.0*x[i][j+6][k];
                a2[6]=-0.71484375*x[i][j+9][k]+x[i][j+7][k];
                //pre
                a3[0]=x[i][j-8][k]*pid0;
                a3[1]=(-a2[6]+32.0*a1[k][0])*pid1;
                a3[2]=(-a2[5]+14.0*a1[k][1])*pid2;
                a3[3]=(-a2[4]+8.0*a1[k][2])*pid3;
                a3[4]=(-a2[3]+4.75*a1[k][3])*pid4;
                a3[5]=(-a2[2]+3.0*a1[k][4])*pid5;
                a3[6]=(-a2[1]+2.0*a1[k][5])*pid6;
                a3[7]=(-0.71484375*a2[0]+a1[k][6])*pid7;
                a3[8]=x[i][j][k]*pid0;
                a3[9]=(a2[0]+0.71484375*a1[k][6])*pid1;
                a3[10]=(2.0*a2[1]+a1[k][5])*pid2;
                a3[11]=(3.0*a2[2]+a1[k][4])*pid3;
                a3[12]=(4.75*a2[3]+a1[k][3])*pid4;
                a3[13]=(8.0*a2[4]+a1[k][2])*pid5;
                a3[14]=(14.0*a2[5]+a1[k][1])*pid6;
                a3[15]=(32.0*a2[6]+a1[k][0])*pid7;
                //idct
                b[4]=a3[0]*0.5-a3[4];
                b[0]=a3[0]-b[4];
                b[2]=a3[2]+a3[6]*u1;      //u1
                b[6]=b[2]*p1-a3[6];       //p1
                a[4]=b[6]+b[4];
                a[6]=b[4]-b[6];
                a[0]=b[0]+b[2];
                a[2]=b[0]-b[2];
                b[7]=a3[1]*0.5-a3[7];
                b[1]=a3[1]-b[7];
                a[7]=a3[5]+b[7];
                a[5]=b[7]-a3[5];
                a[3]=b[1]-a3[3];
                a[1]=a3[3]+b[1];
                a[5]+=a[3]*p5;              //p5
                a[3]-=a[5]*u3;              //u3
                a[5]+=a[3]*p4;              //p4
                a[1]+=a[7]*p3;              //p3
                a[7]-=a[1]*u2;              //u2
                a[1]+=a[7]*p2;              //p2
                x[i][j-4][k]=a[2]-a[7];
                x[i][j-5][k]=a[2]+a[7];
                x[i][j-3][k]=a[6]-a[3];
                x[i][j-6][k]=a[6]+a[3];
                x[i][j-2][k]=a[4]-a[5];
                x[i][j-7][k]=a[4]+a[5];
                x[i][j-1][k]=a[0]-a[1];
                x[i][j-8][k]=a[0]+a[1];
                //pre
                a1[k][0]=x[i][j+9][k]+0.71484375*x[i][j+7][k];
                a1[k][1]=2.0*x[i][j+10][k]+x[i][j+6][k];
                a1[k][2]=3.0*x[i][j+11][k]+x[i][j+5][k];
                a1[k][3]=4.75*x[i][j+12][k]+x[i][j+4][k];
                a1[k][4]=8.0*x[i][j+13][k]+x[i][j+3][k];
                a1[k][5]=14.0*x[i][j+14][k]+x[i][j+2][k];
                a1[k][6]=32.0*x[i][j+15][k]+x[i][j+1][k];
                //idct
                b[4]=a3[8]*0.5-a3[12];
                b[0]=a3[8]-b[4];
                b[2]=a3[10]+a3[14]*u1;     //u1
                b[6]=b[2]*p1-a3[14];       //p1
                a[4]=b[6]+b[4];
                a[6]=b[4]-b[6];
                a[0]=b[0]+b[2];
                a[2]=b[0]-b[2];
                b[7]=a3[9]*0.5-a3[15];
                b[1]=a3[9]-b[7];
                a[7]=a3[13]+b[7];
                a[5]=b[7]-a3[13];
                a[3]=b[1]-a3[11];
                a[1]=a3[11]+b[1];
                a[5]+=a[3]*p5;              //p5
                a[3]-=a[5]*u3;              //u3
                a[5]+=a[3]*p4;              //p4
                a[1]+=a[7]*p3;              //p3
                a[7]-=a[1]*u2;              //u2
                a[1]+=a[7]*p2;              //p2
                x[i][j+4][k]=a[2]-a[7];
                x[i][j+3][k]=a[2]+a[7];
                x[i][j+5][k]=a[6]-a[3];
                x[i][j+2][k]=a[6]+a[3];
                x[i][j+6][k]=a[4]-a[5];
                x[i][j+1][k]=a[4]+a[5];
                x[i][j+7][k]=a[0]-a[1];
                x[i][j][k]=a[0]+a[1];
            }
        }
        for(k=0;k<N;k++)
        {
            //pre mirror down
            a2[0]=31.0*x[i][M-7][k];
            *(a2+1)=13.0*x[i][M-6][k];
            *(a2+2)=7.0*x[i][M-5][k];
            *(a2+3)=3.75*x[i][M-4][k];
            *(a2+4)=2.0*x[i][M-3][k];
            *(a2+5)=x[i][M-2][k];
            *(a2+6)=0.28515625*x[i][M-1][k];
            //pre
            a3[0]=x[i][M-16][k]*pid0;
            a3[1]=(-a2[6]+32.0*a1[k][0])*pid1;
            a3[2]=(-a2[5]+14.0*a1[k][1])*pid2;
            a3[3]=(-a2[4]+8.0*a1[k][2])*pid3;
            a3[4]=(-a2[3]+4.75*a1[k][3])*pid4;
            a3[5]=(-a2[2]+3.0*a1[k][4])*pid5;
            a3[6]=(-a2[1]+2.0*a1[k][5])*pid6;
            a3[7]=(-0.71484375*a2[0]+a1[k][6])*pid7;
            //idct
            b[4]=a3[0]*0.5-a3[4];
            b[0]=a3[0]-b[4];
            b[2]=a3[2]+a3[6]*u1;      //u1
            b[6]=b[2]*p1-a3[6];       //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            b[7]=a3[1]*0.5-a3[7];
            b[1]=a3[1]-b[7];
            a[7]=a3[5]+b[7];
            a[5]=b[7]-a3[5];
            a[3]=b[1]-a3[3];
            a[1]=a3[3]+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][M-12][k]=a[2]-a[7];
            x[i][M-13][k]=a[2]+a[7];
            x[i][M-11][k]=a[6]-a[3];
            x[i][M-14][k]=a[6]+a[3];
            x[i][M-10][k]=a[4]-a[5];
            x[i][M-15][k]=a[4]+a[5];
            x[i][M-9][k]=a[0]-a[1];
            x[i][M-16][k]=a[0]+a[1];
            //dct
            a[0]=x[i][M-8][k]+x[i][M-1][k];
            a[1]=x[i][M-7][k]+x[i][M-2][k];
            a[2]=x[i][M-6][k]+x[i][M-3][k];
            a[3]=x[i][M-5][k]+x[i][M-4][k];
            a[4]=x[i][M-5][k]-x[i][M-4][k];
            a[5]=x[i][M-6][k]-x[i][M-3][k];
            a[6]=x[i][M-7][k]-x[i][M-2][k];
            a[7]=x[i][M-8][k]-x[i][M-1][k];

            c=a[0]+a[3]+a[1]+a[2];
            x[i][M-4][k]=(c*0.5-a[1]-a[2])*d4;
            x[i][M-8][k]=c*d0;

            c=(a[0]-a[3])*p1-a[1]+a[2];   //p1
            x[i][M-6][k]=(a[0]-a[3]-c*u1)*d2;      //u1
            x[i][M-2][k]=c*d6;

            b[7]=a[7]-a[4]*p2;        //p2
            b[1]=a[4]+b[7]*u2;        //u2
            b[7]-=b[1]*p3;            //p3

            b[6]=a[6]-a[5]*p4;        //p4
            b[5]=a[5]+b[6]*u3;        //u3
            b[6]-=b[5]*p5;            //p5

            x[i][M-5][k]=(b[7]-b[5])*d3;
            x[i][M-3][k]=(b[1]-b[6])*d5;

            c=b[7]+b[5]+b[1]+b[6];
            x[i][M-1][k]=(c*0.5-b[1]-b[6])*d7;
            x[i][M-7][k]=c*d1;

        }
    }
	for (int i = 0; i < N; i++)
		free(a1[i]);
	free(a1);
}
void ODD_SCWP_column_Method2(float ***x,int M,int N)
{
    //float a1[N][7];
	float **a1 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a1[i] = (float*)malloc(sizeof(float)* 7);
    float a2[7];
    float a3[16];
    float a[8];
    float b[8];
    float c;
    for(i=0;i<96;i++)
    {
        for(k=0;k<N;k++)
        {
            //pre mirror up
            a1[k][0]=1.71484375*x[i][1][k];
            a1[k][1]=3.0*x[i][2][k];
            a1[k][2]=4.0*x[i][3][k];
            a1[k][3]=5.75*x[i][4][k];
            a1[k][4]=9.0*x[i][5][k];
            a1[k][5]=15.0*x[i][6][k];
            a1[k][6]=33.0*x[i][7][k];
            //pre
            a2[0]=-x[i][23][k]+32.0*x[i][9][k];
            a2[1]=-x[i][22][k]+14.0*x[i][10][k];
            a2[2]=-x[i][21][k]+8.0*x[i][11][k];
            a2[3]=-x[i][20][k]+4.75*x[i][12][k];
            a2[4]=(-x[i][19][k]+3.0*x[i][13][k]);
            a2[5]=(-x[i][18][k]+2.0*x[i][14][k]);
            a2[6]=(-0.71484375*x[i][17][k]+x[i][15][k]);
            //pre
            *(a3+8)=x[i][8][k]*pid0;
            *(a3+9)=(a2[0]+0.71484375*a1[k][6])*pid1;
            *(a3+10)=(2.0*a2[1]+a1[k][5])*pid2;
            *(a3+11)=(3.0*a2[2]+a1[k][4])*pid3;
            *(a3+12)=(4.75*a2[3]+a1[k][3])*pid4;
            *(a3+13)=(8.0*a2[4]+a1[k][2])*pid5;
            *(a3+14)=(14.0*a2[5]+a1[k][1])*pid6;
            *(a3+15)=(32.0*a2[6]+a1[k][0])*pid7;
            //pre
            a1[k][0]=(x[i][17][k]+0.71484375*x[i][15][k]);
            a1[k][1]=(2.0*x[i][18][k]+x[i][14][k]);
            a1[k][2]=(3.0*x[i][19][k]+x[i][13][k]);
            a1[k][3]=(4.75*x[i][20][k]+x[i][12][k]);
            a1[k][4]=(8.0*x[i][21][k]+x[i][11][k]);
            a1[k][5]=(14.0*x[i][22][k]+x[i][10][k]);
            a1[k][6]=(32.0*x[i][23][k]+x[i][9][k]);
            //dct
            a[0]=x[i][0][k]+x[i][7][k];
            a[1]=x[i][1][k]+x[i][6][k];
            a[2]=x[i][2][k]+x[i][5][k];
            a[3]=x[i][3][k]+x[i][4][k];
            a[4]=x[i][3][k]-x[i][4][k];
            a[5]=x[i][2][k]-x[i][5][k];
            a[6]=x[i][1][k]-x[i][6][k];
            a[7]=x[i][0][k]-x[i][7][k];

            c=a[0]+a[3]+a[1]+a[2];
            x[i][4][k]=(c*0.5-a[1]-a[2])*d4;
            x[i][0][k]=c*d0;

            c=(a[0]-a[3])*p1-a[1]+a[2];   //p1
            x[i][2][k]=(a[0]-a[3]-c*u1)*d2;      //u1
            x[i][6][k]=c*d6;

            b[7]=a[7]-a[4]*p2;        //p2
            b[1]=a[4]+b[7]*u2;        //u2
            b[7]-=b[1]*p3;            //p3

            b[6]=a[6]-a[5]*p4;        //p4
            b[5]=a[5]+b[6]*u3;        //u3
            b[6]-=b[5]*p5;            //p5

            x[i][3][k]=(b[7]-b[5])*d3;
            x[i][5][k]=(b[1]-b[6])*d5;

            c=b[7]+b[5]+b[1]+b[6];
            x[i][7][k]=(c*0.5-b[1]-b[6])*d7;
            x[i][1][k]=c*d1;
            //idct
            b[4]=a3[8]*0.5-a3[12];
            b[0]=a3[8]-b[4];
            b[2]=a3[10]+a3[14]*u1;     //u1
            b[6]=b[2]*p1-a3[14];       //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            b[7]=a3[9]*0.5-a3[15];
            b[1]=a3[9]-b[7];
            a[7]=a3[13]+b[7];
            a[5]=b[7]-a3[13];
            a[3]=b[1]-a3[11];
            a[1]=a3[11]+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][12][k]=a[2]-a[7];
            x[i][11][k]=a[2]+a[7];
            x[i][13][k]=a[6]-a[3];
            x[i][10][k]=a[6]+a[3];
            x[i][14][k]=a[4]-a[5];
            x[i][9][k]=a[4]+a[5];
            x[i][15][k]=a[0]-a[1];
            x[i][8][k]=a[0]+a[1];
        }
        for(j=24;j<M-8;j+=16)
        {
            for(k=0;k<N;k++)
            {
                //pre
                a2[0]=-x[i][j+15][k]+32.0*x[i][j+1][k];
                a2[1]=-x[i][j+14][k]+14.0*x[i][j+2][k];
                a2[2]=-x[i][j+13][k]+8.0*x[i][j+3][k];
                a2[3]=-x[i][j+12][k]+4.75*x[i][j+4][k];
                a2[4]=-x[i][j+11][k]+3.0*x[i][j+5][k];
                a2[5]=-x[i][j+10][k]+2.0*x[i][j+6][k];
                a2[6]=-0.71484375*x[i][j+9][k]+x[i][j+7][k];
                //pre
                a3[0]=x[i][j-8][k]*pid0;
                a3[1]=(-a2[6]+32.0*a1[k][0])*pid1;
                a3[2]=(-a2[5]+14.0*a1[k][1])*pid2;
                a3[3]=(-a2[4]+8.0*a1[k][2])*pid3;
                a3[4]=(-a2[3]+4.75*a1[k][3])*pid4;
                a3[5]=(-a2[2]+3.0*a1[k][4])*pid5;
                a3[6]=(-a2[1]+2.0*a1[k][5])*pid6;
                a3[7]=(-0.71484375*a2[0]+a1[k][6])*pid7;
                a3[8]=x[i][j][k]*pid0;
                a3[9]=(a2[0]+0.71484375*a1[k][6])*pid1;
                a3[10]=(2.0*a2[1]+a1[k][5])*pid2;
                a3[11]=(3.0*a2[2]+a1[k][4])*pid3;
                a3[12]=(4.75*a2[3]+a1[k][3])*pid4;
                a3[13]=(8.0*a2[4]+a1[k][2])*pid5;
                a3[14]=(14.0*a2[5]+a1[k][1])*pid6;
                a3[15]=(32.0*a2[6]+a1[k][0])*pid7;
                //idct
                b[4]=a3[0]*0.5-a3[4];
                b[0]=a3[0]-b[4];
                b[2]=a3[2]+a3[6]*u1;      //u1
                b[6]=b[2]*p1-a3[6];       //p1
                a[4]=b[6]+b[4];
                a[6]=b[4]-b[6];
                a[0]=b[0]+b[2];
                a[2]=b[0]-b[2];
                b[7]=a3[1]*0.5-a3[7];
                b[1]=a3[1]-b[7];
                a[7]=a3[5]+b[7];
                a[5]=b[7]-a3[5];
                a[3]=b[1]-a3[3];
                a[1]=a3[3]+b[1];
                a[5]+=a[3]*p5;              //p5
                a[3]-=a[5]*u3;              //u3
                a[5]+=a[3]*p4;              //p4
                a[1]+=a[7]*p3;              //p3
                a[7]-=a[1]*u2;              //u2
                a[1]+=a[7]*p2;              //p2
                x[i][j-4][k]=a[2]-a[7];
                x[i][j-5][k]=a[2]+a[7];
                x[i][j-3][k]=a[6]-a[3];
                x[i][j-6][k]=a[6]+a[3];
                x[i][j-2][k]=a[4]-a[5];
                x[i][j-7][k]=a[4]+a[5];
                x[i][j-1][k]=a[0]-a[1];
                x[i][j-8][k]=a[0]+a[1];
                //pre
                a1[k][0]=x[i][j+9][k]+0.71484375*x[i][j+7][k];
                a1[k][1]=2.0*x[i][j+10][k]+x[i][j+6][k];
                a1[k][2]=3.0*x[i][j+11][k]+x[i][j+5][k];
                a1[k][3]=4.75*x[i][j+12][k]+x[i][j+4][k];
                a1[k][4]=8.0*x[i][j+13][k]+x[i][j+3][k];
                a1[k][5]=14.0*x[i][j+14][k]+x[i][j+2][k];
                a1[k][6]=32.0*x[i][j+15][k]+x[i][j+1][k];
                //idct
                b[4]=a3[8]*0.5-a3[12];
                b[0]=a3[8]-b[4];
                b[2]=a3[10]+a3[14]*u1;     //u1
                b[6]=b[2]*p1-a3[14];       //p1
                a[4]=b[6]+b[4];
                a[6]=b[4]-b[6];
                a[0]=b[0]+b[2];
                a[2]=b[0]-b[2];
                b[7]=a3[9]*0.5-a3[15];
                b[1]=a3[9]-b[7];
                a[7]=a3[13]+b[7];
                a[5]=b[7]-a3[13];
                a[3]=b[1]-a3[11];
                a[1]=a3[11]+b[1];
                a[5]+=a[3]*p5;              //p5
                a[3]-=a[5]*u3;              //u3
                a[5]+=a[3]*p4;              //p4
                a[1]+=a[7]*p3;              //p3
                a[7]-=a[1]*u2;              //u2
                a[1]+=a[7]*p2;              //p2
                x[i][j+4][k]=a[2]-a[7];
                x[i][j+3][k]=a[2]+a[7];
                x[i][j+5][k]=a[6]-a[3];
                x[i][j+2][k]=a[6]+a[3];
                x[i][j+6][k]=a[4]-a[5];
                x[i][j+1][k]=a[4]+a[5];
                x[i][j+7][k]=a[0]-a[1];
                x[i][j][k]=a[0]+a[1];
            }
        }
        for(k=0;k<N;k++)
        {
            a[0]=x[i][M-8][k]+x[i][M-1][k];
            a[1]=x[i][M-7][k]+x[i][M-2][k];
            a[2]=x[i][M-6][k]+x[i][M-3][k];
            a[3]=x[i][M-5][k]+x[i][M-4][k];
            a[4]=x[i][M-5][k]-x[i][M-4][k];
            a[5]=x[i][M-6][k]-x[i][M-3][k];
            a[6]=x[i][M-7][k]-x[i][M-2][k];
            a[7]=x[i][M-8][k]-x[i][M-1][k];

            c=a[0]+a[3]+a[1]+a[2];
            x[i][M-4][k]=(c*0.5-a[1]-a[2])*d4;
            x[i][M-8][k]=c*d0;

            c=(a[0]-a[3])*p1-a[1]+a[2];   //p1
            x[i][M-6][k]=(a[0]-a[3]-c*u1)*d2;      //u1
            x[i][M-2][k]=c*d6;

            b[7]=a[7]-a[4]*p2;        //p2
            b[1]=a[4]+b[7]*u2;        //u2
            b[7]-=b[1]*p3;            //p3

            b[6]=a[6]-a[5]*p4;        //p4
            b[5]=a[5]+b[6]*u3;        //u3
            b[6]-=b[5]*p5;            //p5

            x[i][M-5][k]=(b[7]-b[5])*d3;
            x[i][M-3][k]=(b[1]-b[6])*d5;

            c=b[7]+b[5]+b[1]+b[6];
            x[i][M-1][k]=(c*0.5-b[1]-b[6])*d7;
            x[i][M-7][k]=c*d1;
        }
    }
	for (int i = 0; i < N; i++)
		free(a1[i]);
	free(a1);
}
void i_EVEN_SCWP_column_Method2(float ***x,int M,int N)
{
    float a[8];
    float b[8];
    float a1[7];
    float a2[7];
    float a3[7];
    //float a4[N][7];
	float **a4 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a4[i] = (float*)malloc(sizeof(float)* 7);
    float c;
    for(i=0;i<96;i++)
    {
        for(k=0;k<N;k++)
        {
            //8位IDCT，并乘以系数
            *(b+4)=x[i][0][k]*id0*0.5-x[i][4][k]*id4;
            *b=x[i][0][k]*id0-*(b+4);
            *(b+2)=x[i][2][k]*id2+x[i][6][k]*id6*u1;   //u1
            *(b+6)=*(b+2)*p1-x[i][6][k]*id6;           //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            *(b+7)=x[i][1][k]*id1*0.5-x[i][7][k]*id7;
            *(b+1)=x[i][1][k]*id1-*(b+7);
            a[7]=x[i][5][k]*id5+b[7];
            a[5]=b[7]-x[i][5][k]*id5;
            a[3]=b[1]-x[i][3][k]*id3;
            a[1]=x[i][3][k]*id3+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][4][k]=a[2]-a[7];
            x[i][3][k]=a[2]+a[7];
            x[i][5][k]=a[6]-a[3];
            x[i][2][k]=a[6]+a[3];
            x[i][6][k]=a[4]-a[5];
            x[i][1][k]=a[4]+a[5];
            x[i][7][k]=a[0]-a[1];
            x[i][0][k]=a[0]+a[1];
            //8位DCT，并乘以系数
            a[0]=x[i][8][k]+x[i][15][k];
            a[1]=x[i][9][k]+x[i][14][k];
            a[2]=x[i][10][k]+x[i][13][k];
            a[3]=x[i][11][k]+x[i][12][k];
            a[4]=x[i][11][k]-x[i][12][k];
            a[5]=x[i][10][k]-x[i][13][k];
            a[6]=x[i][9][k]-x[i][14][k];
            a[7]=x[i][8][k]-x[i][15][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a1[3]=(c/2-b[4])*ipd4;
            x[i][8][k]=c*ipd0;

            c=b[3]*p1-b[2];            //p1
            a1[1]=(b[3]-c*u1)*ipd2;    //u1
            a1[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a1[2]=(b[7]-b[5])*ipd3;
            a1[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a1[6]=(c/2-b[1])*ipd7;
            a1[0]=c*ipd1;
            //dct
            a[0]=x[i][16][k]+x[i][23][k];
            a[1]=x[i][17][k]+x[i][22][k];
            a[2]=x[i][18][k]+x[i][21][k];
            a[3]=x[i][19][k]+x[i][20][k];
            a[4]=x[i][19][k]-x[i][20][k];
            a[5]=x[i][18][k]-x[i][21][k];
            a[6]=x[i][17][k]-x[i][22][k];
            a[7]=x[i][16][k]-x[i][23][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a2[3]=(c/2-b[4])*ipd4;
            x[i][16][k]=c*ipd0;

            c=b[3]*p1-b[2];           //p1
            a2[1]=(b[3]-c*u1)*ipd2;   //u1
            a2[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a2[2]=(b[7]-b[5])*ipd3;
            a2[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a2[6]=(c/2-b[1])*ipd7;
            a2[0]=c*ipd1;
            //ipre up mirror
            a4[k][0]=(a1[0]/0.000645670901041-0.71484375*(33.0*x[i][7][k]))*0.000975609756098;             //s1*c7*s1*c7,s1*s1
            a4[k][1]=(a1[1]/0.001015228426396-(15.0*x[i][6][k]))/2*0.005076142131980;
            a4[k][2]=(a1[2]/0.001538461538462-(9.0*x[i][5][k]))/3.0*0.015384615384615;
            a4[k][3]=(a1[3]/0.001801180617608-(5.75*x[i][4][k]))/4.75*0.042440318302387;
            a4[k][4]=(a1[4]/0.001538461538462-(4.0*x[i][3][k]))/8*0.1;
            a4[k][5]=(a1[5]/0.001015228426396-(3.0*x[i][2][k]))/14*0.2;                                    //s2*s6*s2*s6,s6*s6
            a4[k][6]=(a1[6]/0.000645670901041-(1.71484375*x[i][1][k]))/32*0.661812673567281;
            //dct
            a[0]=x[i][24][k]+x[i][31][k];
            a[1]=x[i][25][k]+x[i][30][k];
            a[2]=x[i][26][k]+x[i][29][k];
            a[3]=x[i][27][k]+x[i][28][k];
            a[4]=x[i][27][k]-x[i][28][k];
            a[5]=x[i][26][k]-x[i][29][k];
            a[6]=x[i][25][k]-x[i][30][k];
            a[7]=x[i][24][k]-x[i][31][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a1[3]=(c/2-b[4])*ipd4;
            x[i][24][k]=c*ipd0;

            c=b[3]*p1-b[2];            //p1
            a1[1]=(b[3]-c*u1)*ipd2;    //u1
            a1[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a1[2]=(b[7]-b[5])*ipd3;
            a1[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a1[6]=(c/2-b[1])*ipd7;
            a1[0]=c*ipd1;
            //ipre
            a3[0]=(a1[6]+32.0*a2[0]);
            a3[1]=(a1[5]+14.0*a2[1]);
            a3[2]=(a1[4]+8.0*a2[2]);
            a3[3]=(a1[3]+4.75*a2[3]);
            a3[4]=(a1[2]+3.0*a2[4]);
            a3[5]=(a1[1]+2.0*a2[5]);
            a3[6]=(0.71484375*a1[0]+a2[6]);
            //ipre
            x[i][9][k]=(*(a3+6)+32.0*a4[k][0]);
            x[i][10][k]=(*(a3+5)+14.0*a4[k][1]);
            x[i][11][k]=(*(a3+4)+8.0*a4[k][2]);
            x[i][12][k]=(*(a3+3)+4.75*a4[k][3]);
            x[i][13][k]=(*(a3+2)+3.0*a4[k][4]);
            x[i][14][k]=(*(a3+1)+2.0*a4[k][5]);
            x[i][15][k]=(0.71484375**(a3)+a4[k][6]);
            x[i][17][k]=(*(a3)-0.71484375*a4[k][6]);
            x[i][18][k]=(2.0**(a3+1)-a4[k][5]);
            x[i][19][k]=(3.0**(a3+2)-a4[k][4]);
            x[i][20][k]=(4.75**(a3+3)-a4[k][3]);
            x[i][21][k]=(8.0**(a3+4)-a4[k][2]);
            x[i][22][k]=(14.0**(a3+5)-a4[k][1]);
            x[i][23][k]=(32.0**(a3+6)-a4[k][0]);
            //ipre
            a4[k][0]=(a1[0]-0.71484375*a2[6]);
            a4[k][1]=(2.0*a1[1]-a2[5]);
            a4[k][2]=(3.0*a1[2]-a2[4]);
            a4[k][3]=(4.75*a1[3]-a2[3]);
            a4[k][4]=(8.0*a1[4]-a2[2]);
            a4[k][5]=(14.0*a1[5]-a2[1]);
            a4[k][6]=(32.0*a1[6]-a2[0]);

        }
        for(j=32;j<M-16;j+=16)
        {
            for(k=0;k<N;k++)
            {
                //dct
                a[0]=x[i][j][k]+x[i][j+7][k];
                a[1]=x[i][j+1][k]+x[i][j+6][k];
                a[2]=x[i][j+2][k]+x[i][j+5][k];
                a[3]=x[i][j+3][k]+x[i][j+4][k];
                a[4]=x[i][j+3][k]-x[i][j+4][k];
                a[5]=x[i][j+2][k]-x[i][j+5][k];
                a[6]=x[i][j+1][k]-x[i][j+6][k];
                a[7]=x[i][j][k]-x[i][j+7][k];

                b[0]=a[0]+a[3];
                b[3]=a[0]-a[3];

                b[4]=a[1]+a[2];
                b[2]=a[1]-a[2];

                c=b[0]+b[4];
                a1[3]=(c/2-b[4])*ipd4;
                x[i][j][k]=c*ipd0;

                c=b[3]*p1-b[2];            //p1
                a1[1]=(b[3]-c*u1)*ipd2;   //u1
                a1[5]=c*ipd6;

                b[7]=a[7]-a[4]*p2;         //p2
                b[1]=a[4]+b[7]*u2;         //u2
                b[7]-=b[1]*p3;             //p3

                b[6]=a[6]-a[5]*p4;         //p4
                b[5]=a[5]+b[6]*u3;         //u3
                b[6]-=b[5]*p5;             //p5

                a1[2]=(b[7]-b[5])*ipd3;
                a1[4]=(b[1]-b[6])*ipd5;

                b[1]+=b[6];
                b[7]+=b[5];

                c=b[7]+b[1];
                a1[6]=(c/2-b[1])*ipd7;
                a1[0]=c*ipd1;
                //dct
                a[0]=x[i][j+8][k]+x[i][j+15][k];
                a[1]=x[i][j+9][k]+x[i][j+14][k];
                a[2]=x[i][j+10][k]+x[i][j+13][k];
                a[3]=x[i][j+11][k]+x[i][j+12][k];
                a[4]=x[i][j+11][k]-x[i][j+12][k];
                a[5]=x[i][j+10][k]-x[i][j+13][k];
                a[6]=x[i][j+9][k]-x[i][j+14][k];
                a[7]=x[i][j+8][k]-x[i][j+15][k];

                b[0]=a[0]+a[3];
                b[3]=a[0]-a[3];

                b[4]=a[1]+a[2];
                b[2]=a[1]-a[2];

                c=b[0]+b[4];
                a2[3]=(c/2-b[4])*ipd4;
                x[i][j+8][k]=c*ipd0;

                c=b[3]*p1-b[2];            //p1
                a2[1]=(b[3]-c*u1)*ipd2;   //u1
                a2[5]=c*ipd6;

                b[7]=a[7]-a[4]*p2;         //p2
                b[1]=a[4]+b[7]*u2;         //u2
                b[7]-=b[1]*p3;             //p3

                b[6]=a[6]-a[5]*p4;         //p4
                b[5]=a[5]+b[6]*u3;         //u3
                b[6]-=b[5]*p5;             //p5

                a2[2]=(b[7]-b[5])*ipd3;
                a2[4]=(b[1]-b[6])*ipd5;

                b[1]+=b[6];
                b[7]+=b[5];

                c=b[7]+b[1];
                a2[6]=(c/2-b[1])*ipd7;
                a2[0]=c*ipd1;
                //ipre
                *(a3)=(*(a2+6)+32.0**(a1));
                *(a3+1)=(*(a2+5)+14.0**(a1+1));
                *(a3+2)=(*(a2+4)+8.0**(a1+2));
                *(a3+3)=(*(a2+3)+4.75**(a1+3));
                *(a3+4)=(*(a2+2)+3.0**(a1+4));
                *(a3+5)=(*(a2+1)+2.0**(a1+5));
                *(a3+6)=(0.71484375**(a2)+*(a1+6));
                //ipre
                x[i][j-7][k]=(*(a3+6)+32.0*a4[k][0]);
                x[i][j-6][k]=(*(a3+5)+14.0*a4[k][1]);
                x[i][j-5][k]=(*(a3+4)+8.0*a4[k][2]);
                x[i][j-4][k]=(*(a3+3)+4.75*a4[k][3]);
                x[i][j-3][k]=(*(a3+2)+3.0*a4[k][4]);
                x[i][j-2][k]=(*(a3+1)+2.0*a4[k][5]);
                x[i][j-1][k]=(0.71484375**(a3)+a4[k][6]);
                x[i][j+1][k]=(*(a3)-0.71484375*a4[k][6]);
                x[i][j+2][k]=(2.0**(a3+1)-a4[k][5]);
                x[i][j+3][k]=(3.0**(a3+2)-a4[k][4]);
                x[i][j+4][k]=(4.75**(a3+3)-a4[k][3]);
                x[i][j+5][k]=(8.0**(a3+4)-a4[k][2]);
                x[i][j+6][k]=(14.0**(a3+5)-a4[k][1]);
                x[i][j+7][k]=(32.0**(a3+6)-a4[k][0]);
                //ipre
                a4[k][0]=(*(a2)-0.71484375**(a1+6));
                a4[k][1]=(2.0**(a2+1)-*(a1+5));
                a4[k][2]=(3.0**(a2+2)-*(a1+4));
                a4[k][3]=(4.75**(a2+3)-*(a1+3));
                a4[k][4]=(8.0**(a2+4)-*(a1+2));
                a4[k][5]=(14.0**(a2+5)-*(a1+1));
                a4[k][6]=(32.0**(a2+6)-*(a1));
            }
        }
        for(k=0;k<N;k++)
        {
            //dct
            a[0]=x[i][M-16][k]+x[i][M-9][k];
            a[1]=x[i][M-15][k]+x[i][M-10][k];
            a[2]=x[i][M-14][k]+x[i][M-11][k];
            a[3]=x[i][M-13][k]+x[i][M-12][k];
            a[4]=x[i][M-13][k]-x[i][M-12][k];
            a[5]=x[i][M-14][k]-x[i][M-11][k];
            a[6]=x[i][M-15][k]-x[i][M-10][k];
            a[7]=x[i][M-16][k]-x[i][M-9][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a2[3]=(c/2-b[4])*ipd4;
            x[i][M-16][k]=c*ipd0;

            c=b[3]*p1-b[2];            //p1
            a2[1]=(b[3]-c*u1)*ipd2;   //u1
            a2[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a2[2]=(b[7]-b[5])*ipd3;
            a2[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a2[6]=(c/2-b[1])*ipd7;
            a2[0]=c*ipd1;
            //idct
            *(b+4)=x[i][M-8][k]*id0*0.5-x[i][M-4][k]*id4;
            *b=x[i][M-8][k]*id0-*(b+4);
            *(b+2)=x[i][M-6][k]*id2+x[i][M-2][k]*id6*u1;   //u1
            *(b+6)=*(b+2)*p1-x[i][M-2][k]*id6;     //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            *(b+7)=x[i][M-7][k]*id1*0.5-x[i][M-1][k]*id7;
            *(b+1)=x[i][M-7][k]*id1-*(b+7);
            a[7]=x[i][M-3][k]*id5+b[7];
            a[5]=b[7]-x[i][M-3][k]*id5;
            a[3]=b[1]-x[i][M-5][k]*id3;
            a[1]=x[i][M-5][k]*id3+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][M-4][k]=a[2]-a[7];
            x[i][M-5][k]=a[2]+a[7];
            x[i][M-3][k]=a[6]-a[3];
            x[i][M-6][k]=a[6]+a[3];
            x[i][M-2][k]=a[4]-a[5];
            x[i][M-7][k]=a[4]+a[5];
            x[i][M-1][k]=a[0]-a[1];
            x[i][M-8][k]=a[0]+a[1];
            //ipre
            a3[0]=(a2[0]/0.000645670901041+(0.28515625*x[i][M-1][k]))/32.0*0.661812673567281;
            a3[1]=(a2[1]/0.001015228426396+(x[i][M-2][k]))/14.0*0.2;                                //s2*s6*s2*s6,s6*s6
            a3[2]=(a2[2]/0.001538461538462+(2.0*x[i][M-3][k]))/8.0*0.1;
            a3[3]=(a2[3]/0.001801180617608+(3.75*x[i][M-4][k]))/4.75*0.042440318302387;
            a3[4]=(a2[4]/0.001538461538462+(7.0*x[i][M-5][k]))/3.0*0.015384615384615;
            a3[5]=(a2[5]/0.001015228426396+(13.0*x[i][M-6][k]))/2.0*0.005076142131980;
            a3[6]=(a2[6]/0.000645670901041+0.71484375*(31.0*x[i][M-7][k]))*0.000975609756098;             //s1*c7*s1*c7,s1*s1


            //ipre
            x[i][M-23][k]=(*(a3+6)+32.0*a4[k][0]);
            x[i][M-22][k]=(*(a3+5)+14.0*a4[k][1]);
            x[i][M-21][k]=(*(a3+4)+8.0*a4[k][2]);
            x[i][M-20][k]=(*(a3+3)+4.75*a4[k][3]);
            x[i][M-19][k]=(*(a3+2)+3.0*a4[k][4]);
            x[i][M-18][k]=(*(a3+1)+2.0*a4[k][5]);
            x[i][M-17][k]=(0.71484375**(a3)+a4[k][6]);
            x[i][M-15][k]=(*(a3)-0.71484375*a4[k][6]);
            x[i][M-14][k]=(2.0**(a3+1)-a4[k][5]);
            x[i][M-13][k]=(3.0**(a3+2)-a4[k][4]);
            x[i][M-12][k]=(4.75**(a3+3)-a4[k][3]);
            x[i][M-11][k]=(8.0**(a3+4)-a4[k][2]);
            x[i][M-10][k]=(14.0**(a3+5)-a4[k][1]);
            x[i][M-9][k]=(32.0**(a3+6)-a4[k][0]);
        }
    }
	for (int i = 0; i < N; i++)
		free(a4[i]);
	free(a4);
}
void i_ODD_SCWP_column_Method2(float ***x,int M,int N)
{
    float a[8];
    float b[8];
    float a1[7];
    float a2[7];
    float a3[7];
    //float a4[N][7];
	float **a4 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a4[i] = (float*)malloc(sizeof(float)* 7);
    float c;
    for(i=0;i<96;i++)
    {
        for(k=0;k<N;k++)
        {
            //8位IDCT，并乘以系数
            *(b+4)=x[i][0][k]*id0*0.5-x[i][4][k]*id4;
            *b=x[i][0][k]*id0-*(b+4);
            *(b+2)=x[i][2][k]*id2+x[i][6][k]*id6*u1;   //u1
            *(b+6)=*(b+2)*p1-x[i][6][k]*id6;           //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            *(b+7)=x[i][1][k]*id1*0.5-x[i][7][k]*id7;
            *(b+1)=x[i][1][k]*id1-*(b+7);
            a[7]=x[i][5][k]*id5+b[7];
            a[5]=b[7]-x[i][5][k]*id5;
            a[3]=b[1]-x[i][3][k]*id3;
            a[1]=x[i][3][k]*id3+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][4][k]=a[2]-a[7];
            x[i][3][k]=a[2]+a[7];
            x[i][5][k]=a[6]-a[3];
            x[i][2][k]=a[6]+a[3];
            x[i][6][k]=a[4]-a[5];
            x[i][1][k]=a[4]+a[5];
            x[i][7][k]=a[0]-a[1];
            x[i][0][k]=a[0]+a[1];
            //8位DCT，并乘以系数
            a[0]=x[i][8][k]+x[i][15][k];
            a[1]=x[i][9][k]+x[i][14][k];
            a[2]=x[i][10][k]+x[i][13][k];
            a[3]=x[i][11][k]+x[i][12][k];
            a[4]=x[i][11][k]-x[i][12][k];
            a[5]=x[i][10][k]-x[i][13][k];
            a[6]=x[i][9][k]-x[i][14][k];
            a[7]=x[i][8][k]-x[i][15][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a1[3]=(c/2-b[4])*ipd4;
            x[i][8][k]=c*ipd0;

            c=b[3]*p1-b[2];            //p1
            a1[1]=(b[3]-c*u1)*ipd2;    //u1
            a1[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a1[2]=(b[7]-b[5])*ipd3;
            a1[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a1[6]=(c/2-b[1])*ipd7;
            a1[0]=c*ipd1;
            //dct
            a[0]=x[i][16][k]+x[i][23][k];
            a[1]=x[i][17][k]+x[i][22][k];
            a[2]=x[i][18][k]+x[i][21][k];
            a[3]=x[i][19][k]+x[i][20][k];
            a[4]=x[i][19][k]-x[i][20][k];
            a[5]=x[i][18][k]-x[i][21][k];
            a[6]=x[i][17][k]-x[i][22][k];
            a[7]=x[i][16][k]-x[i][23][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a2[3]=(c/2-b[4])*ipd4;
            x[i][16][k]=c*ipd0;

            c=b[3]*p1-b[2];           //p1
            a2[1]=(b[3]-c*u1)*ipd2;   //u1
            a2[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a2[2]=(b[7]-b[5])*ipd3;
            a2[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a2[6]=(c/2-b[1])*ipd7;
            a2[0]=c*ipd1;
            //ipre up mirror
            a4[k][0]=(a1[0]/0.000645670901041-0.71484375*(33.0*x[i][7][k]))*0.000975609756098;             //s1*c7*s1*c7,s1*s1
            a4[k][1]=(a1[1]/0.001015228426396-(15.0*x[i][6][k]))/2*0.005076142131980;
            a4[k][2]=(a1[2]/0.001538461538462-(9.0*x[i][5][k]))/3.0*0.015384615384615;
            a4[k][3]=(a1[3]/0.001801180617608-(5.75*x[i][4][k]))/4.75*0.042440318302387;
            a4[k][4]=(a1[4]/0.001538461538462-(4.0*x[i][3][k]))/8*0.1;
            a4[k][5]=(a1[5]/0.001015228426396-(3.0*x[i][2][k]))/14*0.2;                                  //s2*s6*s2*s6,s6*s6
            a4[k][6]=(a1[6]/0.000645670901041-(1.71484375*x[i][1][k]))/32*0.661812673567281;
            //dct
            a[0]=x[i][24][k]+x[i][31][k];
            a[1]=x[i][25][k]+x[i][30][k];
            a[2]=x[i][26][k]+x[i][29][k];
            a[3]=x[i][27][k]+x[i][28][k];
            a[4]=x[i][27][k]-x[i][28][k];
            a[5]=x[i][26][k]-x[i][29][k];
            a[6]=x[i][25][k]-x[i][30][k];
            a[7]=x[i][24][k]-x[i][31][k];

            b[0]=a[0]+a[3];
            b[3]=a[0]-a[3];

            b[4]=a[1]+a[2];
            b[2]=a[1]-a[2];

            c=b[0]+b[4];
            a1[3]=(c/2-b[4])*ipd4;
            x[i][24][k]=c*ipd0;

            c=b[3]*p1-b[2];            //p1
            a1[1]=(b[3]-c*u1)*ipd2;    //u1
            a1[5]=c*ipd6;

            b[7]=a[7]-a[4]*p2;         //p2
            b[1]=a[4]+b[7]*u2;         //u2
            b[7]-=b[1]*p3;             //p3

            b[6]=a[6]-a[5]*p4;         //p4
            b[5]=a[5]+b[6]*u3;         //u3
            b[6]-=b[5]*p5;             //p5

            a1[2]=(b[7]-b[5])*ipd3;
            a1[4]=(b[1]-b[6])*ipd5;

            b[1]+=b[6];
            b[7]+=b[5];

            c=b[7]+b[1];
            a1[6]=(c/2-b[1])*ipd7;
            a1[0]=c*ipd1;
            //ipre
            a3[0]=(a1[6]+32.0*a2[0]);
            a3[1]=(a1[5]+14.0*a2[1]);
            a3[2]=(a1[4]+8.0*a2[2]);
            a3[3]=(a1[3]+4.75*a2[3]);
            a3[4]=(a1[2]+3.0*a2[4]);
            a3[5]=(a1[1]+2.0*a2[5]);
            a3[6]=(0.71484375*a1[0]+a2[6]);
            //ipre
            x[i][9][k]=(*(a3+6)+32.0*a4[k][0]);
            x[i][10][k]=(*(a3+5)+14.0*a4[k][1]);
            x[i][11][k]=(*(a3+4)+8.0*a4[k][2]);
            x[i][12][k]=(*(a3+3)+4.75*a4[k][3]);
            x[i][13][k]=(*(a3+2)+3.0*a4[k][4]);
            x[i][14][k]=(*(a3+1)+2.0*a4[k][5]);
            x[i][15][k]=(0.71484375**(a3)+a4[k][6]);
            x[i][17][k]=(*(a3)-0.71484375*a4[k][6]);
            x[i][18][k]=(2.0**(a3+1)-a4[k][5]);
            x[i][19][k]=(3.0**(a3+2)-a4[k][4]);
            x[i][20][k]=(4.75**(a3+3)-a4[k][3]);
            x[i][21][k]=(8.0**(a3+4)-a4[k][2]);
            x[i][22][k]=(14.0**(a3+5)-a4[k][1]);
            x[i][23][k]=(32.0**(a3+6)-a4[k][0]);
            //ipre
            a4[k][0]=(a1[0]-0.71484375*a2[6]);
            a4[k][1]=(2.0*a1[1]-a2[5]);
            a4[k][2]=(3.0*a1[2]-a2[4]);
            a4[k][3]=(4.75*a1[3]-a2[3]);
            a4[k][4]=(8.0*a1[4]-a2[2]);
            a4[k][5]=(14.0*a1[5]-a2[1]);
            a4[k][6]=(32.0*a1[6]-a2[0]);
        }
        for(j=32;j<M-16;j+=16)
        {
            for(k=0;k<N;k++)
            {
                //dct
                a[0]=x[i][j][k]+x[i][j+7][k];
                a[1]=x[i][j+1][k]+x[i][j+6][k];
                a[2]=x[i][j+2][k]+x[i][j+5][k];
                a[3]=x[i][j+3][k]+x[i][j+4][k];
                a[4]=x[i][j+3][k]-x[i][j+4][k];
                a[5]=x[i][j+2][k]-x[i][j+5][k];
                a[6]=x[i][j+1][k]-x[i][j+6][k];
                a[7]=x[i][j][k]-x[i][j+7][k];

                b[0]=a[0]+a[3];
                b[3]=a[0]-a[3];

                b[4]=a[1]+a[2];
                b[2]=a[1]-a[2];

                c=b[0]+b[4];
                a1[3]=(c/2-b[4])*ipd4;
                x[i][j][k]=c*ipd0;

                c=b[3]*p1-b[2];            //p1
                a1[1]=(b[3]-c*u1)*ipd2;   //u1
                a1[5]=c*ipd6;

                b[7]=a[7]-a[4]*p2;         //p2
                b[1]=a[4]+b[7]*u2;         //u2
                b[7]-=b[1]*p3;             //p3

                b[6]=a[6]-a[5]*p4;         //p4
                b[5]=a[5]+b[6]*u3;         //u3
                b[6]-=b[5]*p5;             //p5

                a1[2]=(b[7]-b[5])*ipd3;
                a1[4]=(b[1]-b[6])*ipd5;

                b[1]+=b[6];
                b[7]+=b[5];

                c=b[7]+b[1];
                a1[6]=(c/2-b[1])*ipd7;
                a1[0]=c*ipd1;
                //dct
                a[0]=x[i][j+8][k]+x[i][j+15][k];
                a[1]=x[i][j+9][k]+x[i][j+14][k];
                a[2]=x[i][j+10][k]+x[i][j+13][k];
                a[3]=x[i][j+11][k]+x[i][j+12][k];
                a[4]=x[i][j+11][k]-x[i][j+12][k];
                a[5]=x[i][j+10][k]-x[i][j+13][k];
                a[6]=x[i][j+9][k]-x[i][j+14][k];
                a[7]=x[i][j+8][k]-x[i][j+15][k];

                b[0]=a[0]+a[3];
                b[3]=a[0]-a[3];

                b[4]=a[1]+a[2];
                b[2]=a[1]-a[2];

                c=b[0]+b[4];
                a2[3]=(c/2-b[4])*ipd4;
                x[i][j+8][k]=c*ipd0;

                c=b[3]*p1-b[2];            //p1
                a2[1]=(b[3]-c*u1)*ipd2;   //u1
                a2[5]=c*ipd6;

                b[7]=a[7]-a[4]*p2;         //p2
                b[1]=a[4]+b[7]*u2;         //u2
                b[7]-=b[1]*p3;             //p3

                b[6]=a[6]-a[5]*p4;         //p4
                b[5]=a[5]+b[6]*u3;         //u3
                b[6]-=b[5]*p5;             //p5

                a2[2]=(b[7]-b[5])*ipd3;
                a2[4]=(b[1]-b[6])*ipd5;

                b[1]+=b[6];
                b[7]+=b[5];

                c=b[7]+b[1];
                a2[6]=(c/2-b[1])*ipd7;
                a2[0]=c*ipd1;
                //ipre
                *(a3)=(*(a2+6)+32.0**(a1));
                *(a3+1)=(*(a2+5)+14.0**(a1+1));
                *(a3+2)=(*(a2+4)+8.0**(a1+2));
                *(a3+3)=(*(a2+3)+4.75**(a1+3));
                *(a3+4)=(*(a2+2)+3.0**(a1+4));
                *(a3+5)=(*(a2+1)+2.0**(a1+5));
                *(a3+6)=(0.71484375**(a2)+*(a1+6));
                //ipre
                x[i][j-7][k]=(*(a3+6)+32.0*a4[k][0]);
                x[i][j-6][k]=(*(a3+5)+14.0*a4[k][1]);
                x[i][j-5][k]=(*(a3+4)+8.0*a4[k][2]);
                x[i][j-4][k]=(*(a3+3)+4.75*a4[k][3]);
                x[i][j-3][k]=(*(a3+2)+3.0*a4[k][4]);
                x[i][j-2][k]=(*(a3+1)+2.0*a4[k][5]);
                x[i][j-1][k]=(0.71484375**(a3)+a4[k][6]);
                x[i][j+1][k]=(*(a3)-0.71484375*a4[k][6]);
                x[i][j+2][k]=(2.0**(a3+1)-a4[k][5]);
                x[i][j+3][k]=(3.0**(a3+2)-a4[k][4]);
                x[i][j+4][k]=(4.75**(a3+3)-a4[k][3]);
                x[i][j+5][k]=(8.0**(a3+4)-a4[k][2]);
                x[i][j+6][k]=(14.0**(a3+5)-a4[k][1]);
                x[i][j+7][k]=(32.0**(a3+6)-a4[k][0]);
                //ipre
                a4[k][0]=(*(a2)-0.71484375**(a1+6));
                a4[k][1]=(2.0**(a2+1)-*(a1+5));
                a4[k][2]=(3.0**(a2+2)-*(a1+4));
                a4[k][3]=(4.75**(a2+3)-*(a1+3));
                a4[k][4]=(8.0**(a2+4)-*(a1+2));
                a4[k][5]=(14.0**(a2+5)-*(a1+1));
                a4[k][6]=(32.0**(a2+6)-*(a1));
            }
        }
        for(k=0;k<N;k++)
        {
            //IDCT8，并乘以系数
            *(b+4)=x[i][M-8][k]*id0*0.5-x[i][M-4][k]*id4;
            *b=x[i][M-8][k]*id0-*(b+4);
            *(b+2)=x[i][M-6][k]*id2+x[i][M-2][k]*id6*u1;   //u1
            *(b+6)=*(b+2)*p1-x[i][M-2][k]*id6;     //p1
            a[4]=b[6]+b[4];
            a[6]=b[4]-b[6];
            a[0]=b[0]+b[2];
            a[2]=b[0]-b[2];
            *(b+7)=x[i][M-7][k]*id1*0.5-x[i][M-1][k]*id7;
            *(b+1)=x[i][M-7][k]*id1-*(b+7);
            a[7]=x[i][M-3][k]*id5+b[7];
            a[5]=b[7]-x[i][M-3][k]*id5;
            a[3]=b[1]-x[i][M-5][k]*id3;
            a[1]=x[i][M-5][k]*id3+b[1];
            a[5]+=a[3]*p5;              //p5
            a[3]-=a[5]*u3;              //u3
            a[5]+=a[3]*p4;              //p4
            a[1]+=a[7]*p3;              //p3
            a[7]-=a[1]*u2;              //u2
            a[1]+=a[7]*p2;              //p2
            x[i][M-4][k]=a[2]-a[7];
            x[i][M-5][k]=a[2]+a[7];
            x[i][M-3][k]=a[6]-a[3];
            x[i][M-6][k]=a[6]+a[3];
            x[i][M-2][k]=a[4]-a[5];
            x[i][M-7][k]=a[4]+a[5];
            x[i][M-1][k]=a[0]-a[1];
            x[i][M-8][k]=a[0]+a[1];
            //下边界iprefiltering8
            x[i][M-15][k]=(x[i][M-1][k]+a4[k][0]/0.000975609756097)/32.0;
            x[i][M-14][k]=(x[i][M-2][k]+a4[k][1]/0.005076142131980)/14.0;
            x[i][M-13][k]=(x[i][M-3][k]+a4[k][2]/0.015384615384615)/8.0;
            x[i][M-12][k]=(x[i][M-4][k]+a4[k][3]/0.042440318302387)/4.75;
            x[i][M-11][k]=(x[i][M-5][k]+a4[k][4]/0.1)/3.0;
            x[i][M-10][k]=(x[i][M-6][k]+a4[k][5]/0.2)/2.0;
            x[i][M-9][k]=a4[k][6]/0.661812673567281+0.71484375*x[i][M-7][k];
        }
    }
	for (int i = 0; i < N; i++)
		free(a4[i]);
	free(a4);
}
//操作：      计算偶数三维数组深SCWP-4
//前提条件：  x指向三维数组首地址，M为列长度、N为行长度、L为帧数
//后置条件：  三维数组列SCWP-4在原址上计算完成
void EVEN_SCWP4(float ***x,int L,int M,int N)
{
    float a[4];
    //float a1[N][3];
	float **a1 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a1[i] = (float*)malloc(sizeof(float)*3);
    float a2[3];
    float a3[8];
    for(j=0;j<M;j++)
    {
        for(k=0;k<N;k++)
        {
            //prefiltering4,只计算右边序列，除第4位
            a1[k][0]=x[5][j][k]+0.515625*x[3][j][k];
            a1[k][1]=4*x[6][j][k]+x[2][j][k];
            a1[k][2]=12*x[7][j][k]+x[1][j][k];
            //DCT4，并乘以系数
            a[0]=x[0][j][k]+x[1][j][k]+x[2][j][k]+x[3][j][k];
            a[1]=x[0][j][k]-x[1][j][k]-x[2][j][k]+x[3][j][k];
            a[2]=x[0][j][k]-x[3][j][k];
            a[3]=x[0][j][k]+x[1][j][k]-x[2][j][k]-x[3][j][k];

            a[3]/=1.41421356;

            x[0][j][k]=a[0]*D0;
            x[1][j][k]=(a[2]+a[3])*D1;
            x[2][j][k]=a[1]*D2;
            x[3][j][k]=(a[2]-a[3])*D3;
        }
        for(i=8;i<L;i+=8)
        {
            for(k=0;k<N;k++)
            {
                //prefiltering4,只计算左边序列，除第0位
                *(a2+0)=-x[i+7][j][k]+12*x[i+1][j][k];
                *(a2+1)=-x[i+6][j][k]+4*x[i+2][j][k];
                *(a2+2)=-0.515625*x[i+5][j][k]+x[i+3][j][k];
                //prefiltering4,计算全序列，并乘以系数
                *a3=x[i-4][j][k]*ip0;
                *(a3+1)=(-a2[2]+12*a1[k][0])*ip1;
                *(a3+2)=(-a2[1]+4*a1[k][1])*ip2;
                *(a3+3)=(-0.515625*a2[0]+a1[k][2])*ip3;
                *(a3+4)=x[i][j][k]*ip0;
                *(a3+5)=(a2[0]+0.515625*a1[k][2])*ip1;
                *(a3+6)=(4*a2[1]+a1[k][1])*ip2;
                *(a3+7)=(12*a2[2]+a1[k][0])*ip3;
                //IDCT4
                a[0]=*a3;
                a[1]=*(a3+2);
                a[2]=*(a3+1)+*(a3+3);
                a[3]=*(a3+1)-*(a3+3);

                a[3]/=1.41421356;

                x[i-4][j][k]=a[0]+a[1]+a[2]+a[3];
                x[i-3][j][k]=a[0]-a[1]+a[3];
                x[i-2][j][k]=a[0]-a[1]-a[3];
                x[i-1][j][k]=a[0]+a[1]-a[2]-a[3];
                //prefiltering4,只计算右边序列，除第4位
                a1[k][0]=x[i+5][j][k]+0.515625*x[i+3][j][k];
                a1[k][1]=4*x[i+6][j][k]+x[i+2][j][k];
                a1[k][2]=12*x[i+7][j][k]+x[i+1][j][k];
                //IDCT4
                a[0]=*(a3+4);
                a[1]=*(a3+6);
                a[2]=*(a3+5)+*(a3+7);
                a[3]=*(a3+5)-*(a3+7);

                a[3]/=1.41421356;

                x[i][j][k]=a[0]+a[1]+a[2]+a[3];
                x[i+1][j][k]=a[0]-a[1]+a[3];
                x[i+2][j][k]=a[0]-a[1]-a[3];
                x[i+3][j][k]=a[0]+a[1]-a[2]-a[3];

            }
        }
        for(k=0;k<N;k++)
        {
            //DCT4,并乘以系数
            a[0]=x[L-4][j][k]+x[L-3][j][k]+x[L-2][j][k]+x[L-1][j][k];
            a[1]=x[L-4][j][k]-x[L-3][j][k]-x[L-2][j][k]+x[L-1][j][k];
            a[2]=x[L-4][j][k]-x[L-1][j][k];
            a[3]=x[L-4][j][k]+x[L-3][j][k]-x[L-2][j][k]-x[L-1][j][k];

            a[3]/=1.41421356;

            x[L-4][j][k]=a[0]*D0;
            x[L-3][j][k]=(a[2]+a[3])*D1;
            x[L-2][j][k]=a[1]*D2;
            x[L-1][j][k]=(a[2]-a[3])*D3;
        }
    }
	for (int i = 0; i < N; i++)
		free(a1[i]);
	free(a1);
}

void EVEN_SCWP4_Method2(float ***x,int M,int N)
{
    float a[4];
    //float a1[N][3];
	float **a1 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a1[i] = (float*)malloc(sizeof(float)*3);
    float a2[3];
    float a3[8];
    for(j=0;j<M;j++)
    {
        for(k=0;k<N;k++)
        {
            //pre left mirror
            a1[k][0]=1.515625*x[1][j][k];
            a1[k][1]=5*x[2][j][k];
            a1[k][2]=13*x[3][j][k];
            //dct
            a[0]=x[0][j][k]+x[1][j][k]+x[2][j][k]+x[3][j][k];
            a[1]=x[0][j][k]-x[1][j][k]-x[2][j][k]+x[3][j][k];
            a[2]=x[0][j][k]-x[3][j][k];
            a[3]=x[0][j][k]+x[1][j][k]-x[2][j][k]-x[3][j][k];

            a[3]/=1.41421356;

            x[0][j][k]=a[0]*D0;
            x[1][j][k]=(a[2]+a[3])*D1;
            x[2][j][k]=a[1]*D2;
            x[3][j][k]=(a[2]-a[3])*D3;
            //pre
            *(a2+0)=-x[11][j][k]+12*x[5][j][k];
            *(a2+1)=-x[10][j][k]+4*x[6][j][k];
            *(a2+2)=-0.515625*x[9][j][k]+x[7][j][k];
            //pre
            *(a3+4)=x[4][j][k]*ip0;
            *(a3+5)=(a2[0]+0.515625*a1[k][2])*ip1;
            *(a3+6)=(4*a2[1]+a1[k][1])*ip2;
            *(a3+7)=(12*a2[2]+a1[k][0])*ip3;
            //pre
            a1[k][0]=x[9][j][k]+0.515625*x[7][j][k];
            a1[k][1]=4*x[10][j][k]+x[6][j][k];
            a1[k][2]=12*x[11][j][k]+x[5][j][k];
            //idct
            a[0]=*(a3+4);
            a[1]=*(a3+6);
            a[2]=*(a3+5)+*(a3+7);
            a[3]=*(a3+5)-*(a3+7);

            a[3]/=1.41421356;

            x[4][j][k]=a[0]+a[1]+a[2]+a[3];
            x[5][j][k]=a[0]-a[1]+a[3];
            x[6][j][k]=a[0]-a[1]-a[3];
            x[7][j][k]=a[0]+a[1]-a[2]-a[3];
        }
        for(i=12;i<92;i+=8)
        {
            for(k=0;k<N;k++)
            {
                //pre left
                *(a2+0)=-x[i+7][j][k]+12*x[i+1][j][k];
                *(a2+1)=-x[i+6][j][k]+4*x[i+2][j][k];
                *(a2+2)=-0.515625*x[i+5][j][k]+x[i+3][j][k];
                //pre all
                *a3=x[i-4][j][k]*ip0;
                *(a3+1)=(-a2[2]+12*a1[k][0])*ip1;
                *(a3+2)=(-a2[1]+4*a1[k][1])*ip2;
                *(a3+3)=(-0.515625*a2[0]+a1[k][2])*ip3;
                *(a3+4)=x[i][j][k]*ip0;
                *(a3+5)=(a2[0]+0.515625*a1[k][2])*ip1;
                *(a3+6)=(4*a2[1]+a1[k][1])*ip2;
                *(a3+7)=(12*a2[2]+a1[k][0])*ip3;
                //IDCT4
                a[0]=*a3;
                a[1]=*(a3+2);
                a[2]=*(a3+1)+*(a3+3);
                a[3]=*(a3+1)-*(a3+3);

                a[3]/=1.41421356;

                x[i-4][j][k]=a[0]+a[1]+a[2]+a[3];
                x[i-3][j][k]=a[0]-a[1]+a[3];
                x[i-2][j][k]=a[0]-a[1]-a[3];
                x[i-1][j][k]=a[0]+a[1]-a[2]-a[3];
                //prefiltering4,只计算右边序列，除第4位
                a1[k][0]=x[i+5][j][k]+0.515625*x[i+3][j][k];
                a1[k][1]=4*x[i+6][j][k]+x[i+2][j][k];
                a1[k][2]=12*x[i+7][j][k]+x[i+1][j][k];
                //IDCT4
                a[0]=*(a3+4);
                a[1]=*(a3+6);
                a[2]=*(a3+5)+*(a3+7);
                a[3]=*(a3+5)-*(a3+7);

                a[3]/=1.41421356;

                x[i][j][k]=a[0]+a[1]+a[2]+a[3];
                x[i+1][j][k]=a[0]-a[1]+a[3];
                x[i+2][j][k]=a[0]-a[1]-a[3];
                x[i+3][j][k]=a[0]+a[1]-a[2]-a[3];
            }
        }
        for(k=0;k<N;k++)
        {
            //pre mirror right
            a2[0]=11*x[93][j][k];
            a2[1]=3*x[94][j][k];
            a2[2]=0.484375*x[95][j][k];
            //pre
            *a3=x[88][j][k]*ip0;
            *(a3+1)=(-a2[2]+12*a1[k][0])*ip1;
            *(a3+2)=(-a2[1]+4*a1[k][1])*ip2;
            *(a3+3)=(-0.515625*a2[0]+a1[k][2])*ip3;
            //idct
            a[0]=*a3;
            a[1]=*(a3+2);
            a[2]=*(a3+1)+*(a3+3);
            a[3]=*(a3+1)-*(a3+3);

            a[3]/=1.41421356;

            x[88][j][k]=a[0]+a[1]+a[2]+a[3];
            x[89][j][k]=a[0]-a[1]+a[3];
            x[90][j][k]=a[0]-a[1]-a[3];
            x[91][j][k]=a[0]+a[1]-a[2]-a[3];
            //dct
            a[0]=x[92][j][k]+x[93][j][k]+x[94][j][k]+x[95][j][k];
            a[1]=x[92][j][k]-x[93][j][k]-x[94][j][k]+x[95][j][k];
            a[2]=x[92][j][k]-x[95][j][k];
            a[3]=x[92][j][k]+x[93][j][k]-x[94][j][k]-x[95][j][k];

            a[3]/=1.41421356;

            x[92][j][k]=a[0]*D0;
            x[93][j][k]=(a[2]+a[3])*D1;
            x[94][j][k]=a[1]*D2;
            x[95][j][k]=(a[2]-a[3])*D3;
        }
    }
	for (int i = 0; i < N; i++)
		free(a1[i]);
	free(a1);
}

//操作：      计算偶数三维数组深ISCWP-4
//前提条件：  x指向三维数组首地址，M为列长度、N为行长度、L为帧数
//后置条件：  三维数组列SCWP-4在原址上计算完成
void i_EVEN_SCWP4(float ***x,int L,int M,int N)
{
    float a[4];
    float a1[4];
    float a2[4];
    float a3[3];
    //float a4[N][3];
	float **a4 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a4[i] = (float*)malloc(sizeof(float)* 3);
    for(j=0; j<M; j++)
    {
        for(k=0; k<N; k++)
        {
            //IDCT4
            a[0]=x[0][j][k]*D0;
            a[1]=x[2][j][k]*D2;
            a[2]=x[1][j][k]*D1+x[3][j][k]*D3;
            a[3]=x[1][j][k]*D1-x[3][j][k]*D3;

            a[3]/=1.41421356;

            x[0][j][k]=a[0]+a[1]+a[2]+a[3];
            x[1][j][k]=a[0]-a[1]+a[3];
            x[2][j][k]=a[0]-a[1]-a[3];
            x[3][j][k]=a[0]+a[1]-a[2]-a[3];

            //DCT4,并乘以系数
            a[0]=x[4][j][k]+x[5][j][k]+x[6][j][k]+x[7][j][k];
            a[1]=x[4][j][k]-x[5][j][k]-x[6][j][k]+x[7][j][k];
            a[2]=x[4][j][k]-x[7][j][k];
            a[3]=x[4][j][k]+x[5][j][k]-x[6][j][k]-x[7][j][k];

            a[3]/=1.41421356;

            x[4][j][k]=a[0]*ip0;
            *(a1+1)=(a[2]+a[3])*ip1;
            *(a1+2)=a[1]*ip2;
            *(a1+3)=(a[2]-a[3])*ip3;

            //DCT4,并乘以系数
            a[0]=x[8][j][k]+x[9][j][k]+x[10][j][k]+x[11][j][k];
            a[1]=x[8][j][k]-x[9][j][k]-x[10][j][k]+x[11][j][k];
            a[2]=x[8][j][k]-x[11][j][k];
            a[3]=x[8][j][k]+x[9][j][k]-x[10][j][k]-x[11][j][k];

            a[3]/=1.41421356;

            x[8][j][k]=a[0]*ip0;
            a2[1]=(a[2]+a[3])*ip1;
            a2[2]=a[1]*ip2;
            a2[3]=(a[2]-a[3])*ip3;

            //iprefiltering4,前后4位分别存储
            *(a3)=a2[3]+12**(a1+1);
            *(a3+1)=a2[2]+4**(a1+2);
            *(a3+2)=*(a1+3)+0.515625*a2[1];
            a4[k][0]=a2[1]-0.515625**(a1+3);
            a4[k][1]=4*a2[2]-*(a1+2);
            a4[k][2]=12*a2[3]-*(a1+1);

            //上边界iprefiltering4
            x[5][j][k]=*(a3)/0.789971070395371-0.515625*x[3][j][k];       //s3*s3
            x[6][j][k]=(*(a3+1)/0.058823529411765-x[2][j][k])/4;          //s2*s2
            x[7][j][k]=(*(a3+2)/0.006896551724138-x[1][j][k])/12;         //s1*s1
        }
        for(i=12; i<L-8; i+=8)
        {
            for(k=0; k<N; k++)
            {
                //DCT4，并乘以系数
                a[0]=x[i][j][k]+x[i+1][j][k]+x[i+2][j][k]+x[i+3][j][k];
                a[1]=x[i][j][k]-x[i+1][j][k]-x[i+2][j][k]+x[i+3][j][k];
                a[2]=x[i][j][k]-x[i+3][j][k];
                a[3]=x[i][j][k]+x[i+1][j][k]-x[i+2][j][k]-x[i+3][j][k];

                a[3]/=1.41421356;

                x[i][j][k]=a[0]*ip0;
                *(a1+1)=(a[2]+a[3])*ip1;
                *(a1+2)=a[1]*ip2;
                *(a1+3)=(a[2]-a[3])*ip3;

                //DCT4，并乘以系数
                a[0]=x[i+4][j][k]+x[i+5][j][k]+x[i+6][j][k]+x[i+7][j][k];
                a[1]=x[i+4][j][k]-x[i+5][j][k]-x[i+6][j][k]+x[i+7][j][k];
                a[2]=x[i+4][j][k]-x[i+7][j][k];
                a[3]=x[i+4][j][k]+x[i+5][j][k]-x[i+6][j][k]-x[i+7][j][k];

                a[3]/=1.41421356;

                x[i+4][j][k]=a[0]*ip0;
                a2[1]=(a[2]+a[3])*ip1;
                a2[2]=a[1]*ip2;
                a2[3]=(a[2]-a[3])*ip3;

                //iprefiltering4，只计算前3位
                *(a3)=*(a2+3)+12**(a1+1);
                *(a3+1)=*(a2+2)+4**(a1+2);
                *(a3+2)=*(a1+3)+0.515625**(a2+1);
                //iprefiltering4，计算全序列
                x[i-3][j][k]=*(a3+2)+12*a4[k][0];
                x[i-2][j][k]=*(a3+1)+4*a4[k][1];
                x[i-1][j][k]=a4[k][2]+0.515625**(a3);
                x[i+1][j][k]=*(a3)-0.515625*a4[k][2];
                x[i+2][j][k]=4**(a3+1)-a4[k][1];
                x[i+3][j][k]=12**(a3+2)-a4[k][0];
                //iprefiltering,计算后3位
                a4[k][0]=a2[1]-0.515625**(a1+3);
                a4[k][1]=4*a2[2]-*(a1+2);
                a4[k][2]=12*a2[3]-*(a1+1);
            }
        }
        for(k=0;k<N;k++)
        {
            //IDCT4
            a[0]=x[L-4][j][k]*D0;
            a[1]=x[L-2][j][k]*D2;
            a[2]=x[L-3][j][k]*D1+x[L-1][j][k]*D3;
            a[3]=x[L-3][j][k]*D1-x[L-1][j][k]*D3;

            a[3]/=1.41421356;

            x[L-4][j][k]=a[0]+a[1]+a[2]+a[3];
            x[L-3][j][k]=a[0]-a[1]+a[3];
            x[L-2][j][k]=a[0]-a[1]-a[3];
            x[L-1][j][k]=a[0]+a[1]-a[2]-a[3];
            //下边界iprefiltering
            x[L-7][j][k]=(a4[k][0]/0.006896551724138+x[L-1][j][k])/12;
            x[L-6][j][k]=(a4[k][1]/0.058823529411765+x[L-2][j][k])/4;
            x[L-5][j][k]=a4[k][2]/0.789971070395371+0.515625*x[L-3][j][k];
        }
    }
	for (int i = 0; i < N; i++)
		free(a4[i]);
	free(a4);
}
void i_EVEN_SCWP4_Method2(float ***x,int M,int N)
{
    float a[4];
    float a1[3];
    float a2[3];
    float a3[3];
    //float a4[N][3];
	float **a4 = (float**)malloc(sizeof(float*)*N);
	for (int i = 0; i < N; i++)
		a4[i] = (float*)malloc(sizeof(float)* 3);
    for(j=0;j<M;j++)
    {
        for(k=0;k<N;k++)
        {
            //IDCT4
            a[0]=x[0][j][k]*D0;
            a[1]=x[2][j][k]*D2;
            a[2]=x[1][j][k]*D1+x[3][j][k]*D3;
            a[3]=x[1][j][k]*D1-x[3][j][k]*D3;

            a[3]/=1.41421356;

            x[0][j][k]=a[0]+a[1]+a[2]+a[3];
            x[1][j][k]=a[0]-a[1]+a[3];
            x[2][j][k]=a[0]-a[1]-a[3];
            x[3][j][k]=a[0]+a[1]-a[2]-a[3];

            //DCT4,并乘以系数
            a[0]=x[4][j][k]+x[5][j][k]+x[6][j][k]+x[7][j][k];
            a[1]=x[4][j][k]-x[5][j][k]-x[6][j][k]+x[7][j][k];
            a[2]=x[4][j][k]-x[7][j][k];
            a[3]=x[4][j][k]+x[5][j][k]-x[6][j][k]-x[7][j][k];

            a[3]/=1.41421356;

            x[4][j][k]=a[0]*ip0;
            *(a1)=(a[2]+a[3])*ip1;
            *(a1+1)=a[1]*ip2;
            *(a1+2)=(a[2]-a[3])*ip3;
            //ipre left mirror
            //a4[0]=x[4][j][k];
            a4[k][0]=(a1[0]/0.00544807634755428-0.515625*13*x[3][j][k])*0.00689655172413793;
            a4[k][1]=(a1[1]/0.00346020761245674-5*x[2][j][k])/4*0.0588235294117646;
            a4[k][2]=(a1[2]/0.00544807634755428-1.515625*x[1][j][k])/12*0.789971070395371;
            //DCT
            a[0]=x[8][j][k]+x[9][j][k]+x[10][j][k]+x[11][j][k];
            a[1]=x[8][j][k]-x[9][j][k]-x[10][j][k]+x[11][j][k];
            a[2]=x[8][j][k]-x[11][j][k];
            a[3]=x[8][j][k]+x[9][j][k]-x[10][j][k]-x[11][j][k];

            a[3]/=1.41421356;

            x[8][j][k]=a[0]*ip0;
            a2[0]=(a[2]+a[3])*ip1;
            a2[1]=a[1]*ip2;
            a2[2]=(a[2]-a[3])*ip3;
            //DCT
            a[0]=x[12][j][k]+x[13][j][k]+x[14][j][k]+x[15][j][k];
            a[1]=x[12][j][k]-x[13][j][k]-x[14][j][k]+x[15][j][k];
            a[2]=x[12][j][k]-x[15][j][k];
            a[3]=x[12][j][k]+x[13][j][k]-x[14][j][k]-x[15][j][k];

            a[3]/=1.41421356;

            x[12][j][k]=a[0]*ip0;
            a1[0]=(a[2]+a[3])*ip1;
            a1[1]=a[1]*ip2;
            a1[2]=(a[2]-a[3])*ip3;
            //pre
//            a3[0]=-a1[2]+12*a2[0];
//            a3[1]=-a1[1]+4*a2[1];
//            a3[2]=-0.515625*a1[0]+a2[2];

            *(a3)=*(a1+2)+12**(a2);
            *(a3+1)=*(a1+1)+4**(a2+1);
            *(a3+2)=*(a2+2)+0.515625**(a1);

            //pre
            x[5][j][k]=*(a3+2)+12*a4[k][0];
            x[6][j][k]=*(a3+1)+4*a4[k][1];
            x[7][j][k]=a4[k][2]+0.515625**(a3);
            x[9][j][k]=*(a3)-0.515625*a4[k][2];
            x[10][j][k]=4**(a3+1)-a4[k][1];
            x[11][j][k]=12**(a3+2)-a4[k][0];
            //iprefiltering,计算后3位

//            a4[k][0]=a2[0]-0.515625**(a1+2);
//            a4[k][1]=4*a2[1]-*(a1+1);
//            a4[k][2]=12*a2[2]-*(a1);

            a4[k][0]=*(a1)-0.515625**(a2+2);
            a4[k][1]=4**(a1+1)-*(a2+1);
            a4[k][2]=12**(a1+2)-*(a2);
        }
        for(i=16;i<88;i+=8)
        {
            for(k=0;k<N;k++)
            {
                //DCT4，并乘以系数
                a[0]=x[i][j][k]+x[i+1][j][k]+x[i+2][j][k]+x[i+3][j][k];
                a[1]=x[i][j][k]-x[i+1][j][k]-x[i+2][j][k]+x[i+3][j][k];
                a[2]=x[i][j][k]-x[i+3][j][k];
                a[3]=x[i][j][k]+x[i+1][j][k]-x[i+2][j][k]-x[i+3][j][k];

                a[3]/=1.41421356;

                x[i][j][k]=a[0]*ip0;
                *(a1)=(a[2]+a[3])*ip1;
                *(a1+1)=a[1]*ip2;
                *(a1+2)=(a[2]-a[3])*ip3;

                //DCT4，并乘以系数
                a[0]=x[i+4][j][k]+x[i+5][j][k]+x[i+6][j][k]+x[i+7][j][k];
                a[1]=x[i+4][j][k]-x[i+5][j][k]-x[i+6][j][k]+x[i+7][j][k];
                a[2]=x[i+4][j][k]-x[i+7][j][k];
                a[3]=x[i+4][j][k]+x[i+5][j][k]-x[i+6][j][k]-x[i+7][j][k];

                a[3]/=1.41421356;

                x[i+4][j][k]=a[0]*ip0;
                a2[0]=(a[2]+a[3])*ip1;
                a2[1]=a[1]*ip2;
                a2[2]=(a[2]-a[3])*ip3;

                //iprefiltering4，只计算前3位
                *(a3)=*(a2+2)+12**(a1);
                *(a3+1)=*(a2+1)+4**(a1+1);
                *(a3+2)=*(a1+2)+0.515625**(a2);
                //iprefiltering4，计算全序列
                x[i-3][j][k]=*(a3+2)+12*a4[k][0];
                x[i-2][j][k]=*(a3+1)+4*a4[k][1];
                x[i-1][j][k]=a4[k][2]+0.515625**(a3);
                x[i+1][j][k]=*(a3)-0.515625*a4[k][2];
                x[i+2][j][k]=4**(a3+1)-a4[k][1];
                x[i+3][j][k]=12**(a3+2)-a4[k][0];
                //iprefiltering,计算后3位
                a4[k][0]=a2[0]-0.515625**(a1+2);
                a4[k][1]=4*a2[1]-*(a1+1);
                a4[k][2]=12*a2[2]-*(a1);
            }
        }
        for(k=0;k<N;k++)
        {
            //DCT4，并乘以系数
            a[0]=x[88][j][k]+x[89][j][k]+x[90][j][k]+x[91][j][k];
            a[1]=x[88][j][k]-x[89][j][k]-x[90][j][k]+x[91][j][k];
            a[2]=x[88][j][k]-x[91][j][k];
            a[3]=x[88][j][k]+x[89][j][k]-x[90][j][k]-x[91][j][k];

            a[3]/=1.41421356;

            x[88][j][k]=a[0]*ip0;
            *(a1)=(a[2]+a[3])*ip1;
            *(a1+1)=a[1]*ip2;
            *(a1+2)=(a[2]-a[3])*ip3;
            //IDCT
            a[0]=x[92][j][k]*D0;
            a[1]=x[94][j][k]*D2;
            a[2]=x[93][j][k]*D1+x[95][j][k]*D3;
            a[3]=x[93][j][k]*D1-x[95][j][k]*D3;

            a[3]/=1.41421356;

            x[92][j][k]=a[0]+a[1]+a[2]+a[3];
            x[93][j][k]=a[0]-a[1]+a[3];
            x[94][j][k]=a[0]-a[1]-a[3];
            x[95][j][k]=a[0]+a[1]-a[2]-a[3];
            //pre mirror right
            a3[0]=(a1[0]/0.00544807634755428+0.484375*x[95][j][k])/12*0.789971070395371;
            a3[1]=(a1[1]/0.00346020761245674+3*x[94][j][k])/4*0.0588235294117646;
            a3[2]=(a1[2]/0.00544807634755428+0.515625*11*x[93][j][k])*0.00689655172413793;
            //pre
            x[85][j][k]=*(a3+2)+12*a4[k][0];
            x[86][j][k]=*(a3+1)+4*a4[k][1];
            x[87][j][k]=a4[k][2]+0.515625**(a3);
            x[89][j][k]=*(a3)-0.515625*a4[k][2];
            x[90][j][k]=4**(a3+1)-a4[k][1];
            x[91][j][k]=12**(a3+2)-a4[k][0];
        }
    }
	for (int i = 0; i < N; i++)
		free(a4[i]);
	free(a4);
}
void Haar_DWT(float ***x,int L,int M,int N)
{
    float a;
    for(j=0;j<M;j++)
    {
        for(i=0;i<L;i+=8)
        {
            for(k=0;k<N;k++)
            {
                a=x[i][j][k];
                x[i][j][k]=(x[i][j][k]+x[i+4][j][k]);
                x[i+4][j][k]=(a-x[i+4][j][k])*s1;
            }
        }
    }
    for(j=0;j<M;j++)
    {
        for(i=0;i<L;i+=16)
        {
            for(k=0;k<N;k++)
            {
                a=x[i][j][k];
                x[i][j][k]=(x[i][j][k]+x[i+8][j][k]);
                x[i+8][j][k]=(a-x[i+8][j][k])*s2;
            }
        }
    }
    for(j=0;j<M;j++)
    {
        for(i=0;i<L;i+=32)
        {
            for(k=0;k<N;k++)
            {
                a=x[i][j][k];
                x[i][j][k]=(x[i][j][k]+x[i+16][j][k])*s3;
                x[i+16][j][k]=(a-x[i+16][j][k])*s3;
            }
        }
    }
}
void Haar_IDWT(float ***x,int L,int M,int N)
{
    float a;
    for(j=0;j<M;j++)
    {
        for(i=0;i<L;i+=32)
        {
            for(k=0;k<N;k++)
            {
                a=x[i][j][k];
                x[i][j][k]=(x[i][j][k]+x[i+16][j][k])*s1;
                x[i+16][j][k]=(a-x[i+16][j][k])*s1;
            }
        }
    }
    for(j=0;j<M;j++)
    {
        for(i=0;i<L;i+=16)
        {
            for(k=0;k<N;k++)
            {
                a=x[i][j][k];
                x[i][j][k]=(x[i][j][k]+x[i+8][j][k])*s1;
                x[i+8][j][k]=(a-x[i+8][j][k])*s1;
            }
        }
    }
    for(j=0;j<M;j++)
    {
        for(i=0;i<L;i+=8)
        {
            for(k=0;k<N;k++)
            {
                a=x[i][j][k];
                x[i][j][k]=(x[i][j][k]+x[i+4][j][k])*s1;
                x[i+4][j][k]=(a-x[i+4][j][k])*s1;
            }
        }
    }
}
//异址rotation,间隔为8
void rotation_1(float *x,float *y,int m)         //x:轮转的第一个元素的地址,第二个元素相隔;theta为正
{
    *y=*x-0.125**(x+m);
    *(y+2)=0.125**x+*(x+m);
}
//异址i_rotation,间隔为8
void i_rotation_1(float *x,float *y,int m)       //x:轮转的第一个元素的地址,第二个元素相隔;theta为负
{
    *y=*x+0.125**(x+m);
    *(y+2)=-0.125**x+*(x+m);
}
//原址rotation
void rotation_2(float *x,int m)                   //x:轮转的第一个元素的地址,第二个元素相隔;theta为正
{
    float b;
    b=*x;
    *x=*x-0.125**(x+m);
    *(x+m)=0.125*b+*(x+m);
}
//原址i_rotation
void i_rotation_2(float *x,int m)                  //x:轮转的第一个元素的地址,第二个元素相隔;theta为负
{
    float b;
    b=*x;
    *x=*x+0.125**(x+m);
    *(x+m)=-0.125*b+*(x+m);
}
void rotation_3(float *x,float *y,int m)         //x:轮转的第一个元素的地址,第二个元素相隔;theta为正
{
    *y=*x-0.125**(x+m);
    *(y+1)=0.125**x+*(x+m);
}
void rotation_4(float *x,float *y,int m)         //x:轮转的第一个元素的地址,第二个元素相隔;theta为正
{
    *y=*x-0.125**(x+2);
    *(y+m)=0.125**x+*(x+2);
}
void i_rotation_4(float *x,float *y,int m)       //x:轮转的第一个元素的地址,第二个元素相隔;theta为负
{
    *y=*x+0.125**(x+2);
    *(y+m)=-0.125**x+*(x+2);
}
void i_rotation_5(float *x,float *y,int m)
{
    *y=*x+0.125**(x+1);
    *(y+m)=-0.125**x+*(x+1);
}
//Haar_transform,并乘以系数
void Haar_transform(float *x,float *y,int m)
{
    *y=(*x+*(x+1))*s;
    *(y+m)=(*x-*(x+1))*s;
}
void IHaar_transform(float *x,float *y,int m)
{
    *y=(*x+*(x+m))*s;
    *(y+1)=(*x-*(x+m))*s;
}
void PTV1_4k(float *x,float *y,int N)
{
    int l=N/8;
    //float a[l];;
	float *a = (float*)malloc(sizeof(float)*l);
    for(k=1;k<l;k+=4)
    {
        rotation_1(x+k*8,a+k,16);
        i_rotation_1(x+k*8-8,a+k-1,16);
    }
    for(k=3;k<l-4;k+=4)
    {
        rotation_2(a+k,2);
        i_rotation_2(a+k-1,2);
    }
    rotation_2(a,1);
    i_rotation_2(a+l-2,1);
    for(k=0;k<l;k+=2)
    {
        Haar_transform(a+k,y+k,1);
    }
	free(a);
}
void PTV1_4k_2(float *x,float *y,int N)
{
    int l=N/8;
    //float a[l];
	float *a = (float*)malloc(sizeof(float)*l);
    rotation_3(x,a,8);
    for(k=3;k<l;k+=4)
    {
        rotation_1(x+k*8,a+k,16);
        i_rotation_1(x+k*8-8,a+k-1,16);
    }
    for(k=0;k<l-2;k+=4)
    {
        rotation_2(a+k+1,2);
        i_rotation_2(a+k,2);
    }
    i_rotation_2(a+l-2,1);
    for(k=0;k<l;k+=2)
    {
        Haar_transform(a+k,y+k,1);
    }
	free(a);
}
void ODD_PTV1(float *x,float *y,int N)
{
    int l=N/8+1;
    //float a[l];
	float *a = (float*)malloc(sizeof(float)*l);
    if(l%4==0)
    {
        for(k=1;k<l-5;k+=4)
        {
            rotation_1(x+k*8,a+k,16);
            i_rotation_1(x+k*8-8,a+k-1,16);
        }
        i_rotation_1(x+(l-4)*8,a+l-4,16);
        for(k=3;k<l-5;k+=4)
        {
            rotation_2(a+k,2);
            i_rotation_2(a+k-1,2);
        }
        i_rotation_2(a+l-6,2);
        a[l-1]=1.28571429*a[l-2];                           //v
        a[l-3]=1.015625**(x+(l-3)*8)-0.16071429*a[l-2];     //u

        rotation_2(a,1);
        i_rotation_2(a+l-2,1);
        rotation_2(a+l-5,2);

        for(k=0; k<l-3; k+=2)
        {
            Haar_transform(a+k,y+k,1);
        }
        y[l-2]=a[l-2]*2*s;
    }
    else  //l%4!=0
    {
        rotation_3(x,a,8);
        for(k=3;k<l-5;k+=4)
        {
            rotation_1(x+k*8,a+k,16);
            i_rotation_1(x+k*8-8,a+k-1,16);
        }
        i_rotation_1(x+(l-4)*8,a+l-4,16);
        for(k=1;k<l-5;k+=4)
        {
            rotation_2(a+k,2);
            i_rotation_2(a+k-1,2);
        }
        i_rotation_2(a+l-6,2);
        a[l-1]=1.28571429*a[l-2];                           //v
        a[l-3]=1.015625**(x+(l-3)*8)-0.16071429*a[l-2];     //u

        i_rotation_2(a+l-2,1);
        rotation_2(a+l-5,2);
        for(k=0; k<l-3; k+=2)
        {
            Haar_transform(a+k,y+k,1);
        }
        y[l-2]=a[l-2]*2*s;
    }
	free(a);
}
//操作：     将做完SCWP后系数中的直流分量做第一遍行PTV
//前置条件： x:指向做完SCWP后的系数矩阵的行首地址；y:指向存放做完PTV后的直流系数矩阵的行首地址,N:行长度
//后置条件： y:指向存放处理后的系数的首地址
void PTV_Row_1(float *x,float *y,int N)
{
    int q=N/8;
    if(q%4==0)
    {
        PTV1_4k(x,y,N);
    }
    else if(q%4==2)
    {
        PTV1_4k_2(x,y,N);
    }
    else  //l%4==1|l%4==3
    {
        ODD_PTV1(x,y,N);
    }
}
void IPTV1_4k(float *x,float *y,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n;k+=2)
    {
        IHaar_transform(x+k,a+k,1);
    }
    i_rotation_2(a,1);
    rotation_2(a+n-2,1);
    for(k=3;k<n-4;k+=4)
    {
        i_rotation_2(a+k,2);
        rotation_2(a+k-1,2);
    }
    for(k=1;k<n;k+=4)
    {
        i_rotation_4(a+k,y+8*k,16);
        rotation_4(a+k-1,y+8*k-8,16);
    }
	free(a);
}
void IPTV1_4k_2(float *x,float *y,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n;k+=2)
    {
        IHaar_transform(x+k,a+k,1);
    }
    rotation_2(a+n-2,1);
    for(k=0;k<n-2;k+=4)
    {
        i_rotation_2(a+k+1,2);
        rotation_2(a+k,2);
    }
    for(k=3;k<n;k+=4)
    {
        i_rotation_4(a+k,y+k*8,16);
        rotation_4(a+k-1,y+k*8-8,16);
    }
    i_rotation_5(a,y,8);
	free(a);
}
void ODD_IPTV1(float *x,float *y,int n)
{
    n+=1;
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n-2;k+=2)
    {
        IHaar_transform(x+k,a+k,1);
    }
    a[n-1]=a[n-2]=*(x+n-2)*s;

    if(n%4==0)
    {
        i_rotation_2(a,1);
        rotation_2(a+n-2,1);
        for(k=3; k<n-4; k+=4)
        {
            i_rotation_2(a+k,2);
            rotation_2(a+k-1,2);
        }
        for(k=1; k<n-4; k+=4)
        {
            i_rotation_4(a+k,y+k*8,16);
            rotation_4(a+k-1,y+k*8-8,16);
        }
        rotation_4(a+n-4,y+n*8-32,16);
        *(y+n*8-24)=*(a+n-3)+0.125**(a+n-1);
    }
    else
    {
        rotation_2(a+n-2,1);
        for(k=0; k<n-2; k+=4)
        {
            i_rotation_2(a+k+1,2);
            rotation_2(a+k,2);
        }
        for(k=3; k<n-4; k+=4)
        {
            i_rotation_4(a+k,y+k*8,16);
            rotation_4(a+k-1,y+k*8-8,16);
        }
        rotation_4(a+n-4,y+n*8-32,16);
        *(y+n*8-24)=*(a+n-3)+0.125**(a+n-1);
        i_rotation_5(a,y,8);
    }
	free(a);
}
//操作：     原址第一遍行IPTV
//前置条件： x: 指向存放做完第一遍PTV后的直流系数矩阵的行首地址,n:待处理系数个数
//后置条件： 数据在原址上处理完成
void IPTV_Row_1(float *x,float *y,int n)
{
    if(n%4==0)
    {
        IPTV1_4k(x,y,n);
    }
    else if(n%4==2)
    {
        IPTV1_4k_2(x,y,n);
    }
    else  //n%4==1||3
    {
        ODD_IPTV1(x,y,n);
    }
}
void PTV2_4k(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=1;k<n;k+=4)
    {
        rotation_1(x+k*2,a+k,4);
        i_rotation_1(x+k*2-2,a+k-1,4);
    }
    for(k=3;k<n-4;k+=4)
    {
        rotation_2(a+k,2);
        i_rotation_2(a+k-1,2);
    }
    rotation_2(a,1);
    i_rotation_2(a+n-2,1);
    for(k=0;k<n;k+=2)
    {
        Haar_transform(a+k,x+2*k,2);
    }
	free(a);
}
void PTV2_4k_2(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    rotation_3(x,a,2);
    for(k=3;k<n;k+=4)
    {
        rotation_1(x+k*2,a+k,4);
        i_rotation_1(x+k*2-2,a+k-1,4);
    }
    for(k=0;k<n-2;k+=4)
    {
        rotation_2(a+k+1,2);
        i_rotation_2(a+k,2);
    }
    i_rotation_2(a+n-2,1);
    for(k=0;k<n;k+=2)
    {
        Haar_transform(a+k,x+2*k,2);
    }
	free(a);
}
void ODD_PTV2(float *x,int n)
{
    n+=1;
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    if(n%4==0)
    {
        for(k=1;k<n-5;k+=4)
        {
            rotation_1(x+k*2,a+k,4);
            i_rotation_1(x+k*2-2,a+k-1,4);
        }
        i_rotation_1(x+(n-4)*2,a+n-4,4);
        for(k=3;k<n-5;k+=4)
        {
            rotation_2(a+k,2);
            i_rotation_2(a+k-1,2);
        }
        i_rotation_2(a+n-6,2);

        a[n-1]=1.28571429*a[n-2];                           //v
        a[n-3]=1.015625**(x+(n-3)*2)-0.16071429*a[n-2];     //u

        rotation_2(a,1);
        i_rotation_2(a+n-2,1);
        rotation_2(a+n-5,2);

        for(k=0; k<n-3; k+=2)
        {
            Haar_transform(a+k,x+2*k,2);
        }
        x[2*n-4]=a[n-2]*2*s;
    }
    else
    {
        rotation_3(x,a,2);
        for(k=3;k<n-5;k+=4)
        {
            rotation_1(x+k*2,a+k,4);
            i_rotation_1(x+k*2-2,a+k-1,4);
        }
        i_rotation_1(x+(n-4)*2,a+n-4,4);
        for(k=1;k<n-5;k+=4)
        {
            rotation_2(a+k,2);
            i_rotation_2(a+k-1,2);
        }
        i_rotation_2(a+n-6,2);
        a[n-1]=1.28571429*a[n-2];                           //v
        a[n-3]=1.015625**(x+(n-3)*2)-0.16071429*a[n-2];     //u

        i_rotation_2(a+n-2,1);
        rotation_2(a+n-5,2);
        for(k=0; k<n-3; k+=2)
        {
            Haar_transform(a+k,x+2*k,2);
        }
        x[2*n-4]=a[n-2]*2*s;
    }
	free(a);
}
//操作：     原址第二遍行PTV
//前置条件： x: 指向存放做完第一遍PTV后的直流系数矩阵的行首地址,n:待处理系数个数
//后置条件： 数据在原址上处理完成
void PTV_Row_2(float *x,int n)
{
    if(n%4==0)
    {
        PTV2_4k(x,n);
    }
    else if(n%4==2)
    {
        PTV2_4k_2(x,n);
    }
    else
    {
        ODD_PTV2(x,n);
    }

}
void IPTV2_4k(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n;k+=2)
    {
        IHaar_transform(x+2*k,a+k,2);
    }
    i_rotation_2(a,1);
    rotation_2(a+n-2,1);
    for(k=3;k<n-4;k+=4)
    {
        i_rotation_2(a+k,2);
        rotation_2(a+k-1,2);
    }
    for(k=1;k<n;k+=4)
    {
        i_rotation_4(a+k,x+2*k,4);
        rotation_4(a+k-1,x+2*k-2,4);
    }
	free(a);
}
void IPTV2_4k_2(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n;k+=2)
    {
        IHaar_transform(x+2*k,a+k,2);
    }
    rotation_2(a+n-2,1);
    for(k=0;k<n-2;k+=4)
    {
        i_rotation_2(a+k+1,2);
        rotation_2(a+k,2);
    }
    for(k=3;k<n;k+=4)
    {
        i_rotation_4(a+k,x+2*k,4);
        rotation_4(a+k-1,x+2*k-2,4);
    }
    i_rotation_5(a,x,2);
	free(a);
}
void ODD_IPTV2(float *x,int n)
{
    n+=1;
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n-2;k+=2)
    {
        IHaar_transform(x+2*k,a+k,2);
    }
    a[n-1]=a[n-2]=*(x+2*n-4)*s;
    if(n%4==0)
    {
        i_rotation_2(a,1);
        rotation_2(a+n-2,1);
        for(k=3; k<n-4; k+=4)
        {
            i_rotation_2(a+k,2);
            rotation_2(a+k-1,2);
        }
        for(k=1; k<n-4; k+=4)
        {
            i_rotation_4(a+k,x+2*k,4);
            rotation_4(a+k-1,x+2*k-2,4);
        }
        rotation_4(a+n-4,x+2*n-8,4);
        //*(x+2*n-6)=88;
        *(x+2*n-6)=*(a+n-3)+0.125**(a+n-1);
    }
    else
    {
        rotation_2(a+n-2,1);
        for(k=0; k<n-2; k+=4)
        {
            i_rotation_2(a+k+1,2);
            rotation_2(a+k,2);
        }
        for(k=3; k<n-4; k+=4)
        {
            i_rotation_4(a+k,x+2*k,4);
            rotation_4(a+k-1,x+2*k-2,4);
        }
        rotation_4(a+n-4,x+2*n-8,4);
        *(x+2*n-6)=*(a+n-3)+0.125**(a+n-1);
        i_rotation_5(a,x,2);
    }
	free(a);
}
//操作：     原址第二遍行IPTV
//前置条件： x: 指向存放做完第二遍PTV后的直流系数矩阵的行首地址,n:待处理系数个数
//后置条件： 数据在原址上处理完成
void IPTV_Row_2(float *x,int n)
{
    if(n%4==0)
    {
        IPTV2_4k(x,n);
    }
    else if(n%4==2)
    {
        IPTV2_4k_2(x,n);
    }
    else
    {
        ODD_IPTV2(x,n);
    }
}
void PTV3_4k(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=1;k<n;k+=4)
    {
        rotation_1(x+k*4,a+k,8);
        i_rotation_1(x+k*4-4,a+k-1,8);
    }
    for(k=3;k<n-4;k+=4)
    {
        rotation_2(a+k,2);
        i_rotation_2(a+k-1,2);
    }
    rotation_2(a,1);
    i_rotation_2(a+n-2,1);
    for(k=0;k<n;k+=2)
    {
        Haar_transform(a+k,x+4*k,4);
    }
	free(a);
}
void PTV3_4k_2(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    rotation_3(x,a,4);
    for(k=3;k<n;k+=4)
    {
        rotation_1(x+k*4,a+k,8);
        i_rotation_1(x+k*4-4,a+k-1,8);
    }
    for(k=0;k<n-2;k+=4)
    {
        rotation_2(a+k+1,2);
        i_rotation_2(a+k,2);
    }
    i_rotation_2(a+n-2,1);
    for(k=0;k<n;k+=2)
    {
        Haar_transform(a+k,x+4*k,4);
    }
	free(a);
}
void ODD_PTV3(float *x,int n)
{
    n+=1;
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    if(n%4==0)
    {
        for(k=1;k<n-5;k+=4)
        {
            rotation_1(x+k*4,a+k,8);
            i_rotation_1(x+k*4-4,a+k-1,8);
        }
        i_rotation_1(x+(n-4)*4,a+n-4,8);
        for(k=3;k<n-5;k+=4)
        {
            rotation_2(a+k,2);
            i_rotation_2(a+k-1,2);
        }
        i_rotation_2(a+n-6,2);

        a[n-1]=1.28571429*a[n-2];                           //v
        a[n-3]=1.015625**(x+(n-3)*4)-0.16071429*a[n-2];     //u

        rotation_2(a,1);
        i_rotation_2(a+n-2,1);
        rotation_2(a+n-5,2);

        for(k=0; k<n-3; k+=2)
        {
            Haar_transform(a+k,x+4*k,4);
        }
        x[4*n-8]=a[n-2]*2*s;
    }
    else
    {
        rotation_3(x,a,4);
        for(k=3;k<n-5;k+=4)
        {
            rotation_1(x+k*4,a+k,8);
            i_rotation_1(x+k*4-4,a+k-1,8);
        }
        i_rotation_1(x+(n-4)*4,a+n-4,8);
        for(k=1;k<n-5;k+=4)
        {
            rotation_2(a+k,2);
            i_rotation_2(a+k-1,2);
        }
        i_rotation_2(a+n-6,2);
        a[n-1]=1.28571429*a[n-2];                           //v
        a[n-3]=1.015625**(x+(n-3)*4)-0.16071429*a[n-2];     //u

        i_rotation_2(a+n-2,1);
        rotation_2(a+n-5,2);
        for(k=0; k<n-3; k+=2)
        {
            Haar_transform(a+k,x+4*k,4);
        }
        x[4*n-8]=a[n-2]*2*s;
    }
	free(a);
}
//操作：     原址第三遍行PTV
//前置条件： x: 指向存放做完第二遍PTV后的直流系数矩阵的行首地址,n:待处理系数个数
//后置条件： 数据在原址上处理完成
void PTV_Row_3(float *x,int n)
{
    if(n%4==0)
    {
        PTV3_4k(x,n);
    }
    else if(n%4==2)
    {
        PTV3_4k_2(x,n);
    }
    else
    {
        ODD_PTV3(x,n);
    }
}
void IPTV3_4k(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n;k+=2)
    {
        IHaar_transform(x+4*k,a+k,4);
    }
    i_rotation_2(a,1);
    rotation_2(a+n-2,1);
    for(k=3;k<n-4;k+=4)
    {
        i_rotation_2(a+k,2);
        rotation_2(a+k-1,2);
    }
    for(k=1;k<n;k+=4)
    {
        i_rotation_4(a+k,x+4*k,8);
        rotation_4(a+k-1,x+4*k-4,8);
    }
	free(a);
}
void IPTV3_4k_2(float *x,int n)
{
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n;k+=2)
    {
        IHaar_transform(x+4*k,a+k,4);
    }
    rotation_2(a+n-2,1);
    for(k=0;k<n-2;k+=4)
    {
        i_rotation_2(a+k+1,2);
        rotation_2(a+k,2);
    }
    for(k=3;k<n;k+=4)
    {
        i_rotation_4(a+k,x+4*k,8);
        rotation_4(a+k-1,x+4*k-4,8);
    }
    i_rotation_5(a,x,4);
	free(a);
}
void ODD_IPTV3(float *x,int n)
{
    n+=1;
    //float a[n];
	float *a = (float*)malloc(sizeof(float)*n);
    for(k=0;k<n-2;k+=2)
    {
        IHaar_transform(x+4*k,a+k,4);
    }
    a[n-1]=a[n-2]=*(x+4*n-8)*s;
    if(n%4==0)
    {
        i_rotation_2(a,1);
        rotation_2(a+n-2,1);
        for(k=3; k<n-4; k+=4)
        {
            i_rotation_2(a+k,2);
            rotation_2(a+k-1,2);
        }
        for(k=1; k<n-4; k+=4)
        {
            i_rotation_4(a+k,x+4*k,8);
            rotation_4(a+k-1,x+4*k-4,8);
        }
        rotation_4(a+n-4,x+4*n-16,8);
        *(x+4*n-12)=*(a+n-3)+0.125**(a+n-1);
    }
    else
    {
        rotation_2(a+n-2,1);
        for(k=0; k<n-2; k+=4)
        {
            i_rotation_2(a+k+1,2);
            rotation_2(a+k,2);
        }
        for(k=3; k<n-4; k+=4)
        {
            i_rotation_4(a+k,x+4*k,8);
            rotation_4(a+k-1,x+4*k-4,8);
        }
        rotation_4(a+n-4,x+4*n-16,8);
        *(x+4*n-12)=*(a+n-3)+0.125**(a+n-1);
        i_rotation_5(a,x,4);

    }
	free(a);
}
//操作：     原址第三遍行IPTV
//前置条件： x: 指向存放做完第二遍PTV后的直流系数矩阵的行首地址,n:待处理系数个数
//后置条件： 数据在原址上处理完成
void IPTV_Row_3(float *x,int n)
{
    if(n%4==0)
    {
        IPTV3_4k(x,n);
    }
    else if(n%4==2)
    {
        IPTV3_4k_2(x,n);
    }
    else
    {
        ODD_IPTV3(x,n);
    }
}
//m行,n列

void PTV_4k_Column_1(float ***x,int m,int n)
{
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float a[4];
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k++)
        {
            b[k][0]=x[i][0][k]+0.125*x[i][2][k];
            b[k][1]=x[i][1][k]-0.125*x[i][3][k];

            a[0]=b[k][0]-0.125*b[k][1];
            a[1]=0.125*b[k][0]+b[k][1];

            b[k][0]=0.125*x[i][1][k]+x[i][3][k];
            b[k][2]=-0.125*x[i][0][k]+x[i][2][k];

            x[i][0][k]=(a[0]+a[1])*s;
            x[i][1][k]=(a[0]-a[1])*s;
        }
        for(j=2;j<m-2;j+=4)
        {
            for(k=0;k<n;k++)
            {
                //b[0]=0.125*x[i][j-1][k]+x[i][j+1][k];
                b[k][1]=x[i][j+3][k]-0.125*x[i][j+5][k];

                a[1]=b[k][0]-0.125*b[k][1];
                a[3]=0.125*b[k][0]+b[k][1];

                //b[2]=-0.125*x[i][j-2][k]+x[i][j][k];
                b[k][3]=x[i][j+2][k]+0.125*x[i][j+4][k];

                a[0]=b[k][2]+0.125*b[k][3];
                a[2]=-0.125*b[k][2]+b[k][3];

                b[k][0]=0.125*x[i][j+3][k]+x[i][j+5][k];
                b[k][2]=-0.125*x[i][j+2][k]+x[i][j+4][k];

                x[i][j][k]=(a[0]+a[1])*s;
                x[i][j+1][k]=(a[0]-a[1])*s;
                x[i][j+2][k]=(a[2]+a[3])*s;
                x[i][j+3][k]=(a[2]-a[3])*s;
            }
        }
        for(k=0;k<n;k++)
        {
//            printf("%f\n",b[0]);
//            printf("%f\n",b[2]);

            a[0]=b[k][2]+0.125*b[k][0];
            a[1]=-0.125*b[k][2]+b[k][0];

            x[i][m-2][k]=(a[0]+a[1])*s;
            x[i][m-1][k]=(a[0]-a[1])*s;
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void PTV_4k_2_Column_1(float ***x,int m,int n)
{
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float a[4];
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k++)
        {
            b[k][0]=x[i][0][k]-0.125*x[i][1][k];
            b[k][1]=0.125*x[i][0][k]+x[i][1][k];
            b[k][2]=x[i][3][k]-0.125*x[i][5][k];
            b[k][3]=x[i][2][k]+0.125*x[i][4][k];

            a[0]=b[k][0]+0.125*b[k][3];
            a[1]=b[k][1]-0.125*b[k][2];
            a[2]=-0.125*b[k][0]+b[k][3];
            a[3]=0.125*b[k][1]+b[k][2];

            b[k][0]=0.125*x[i][3][k]+x[i][5][k];
            b[k][2]=-0.125*x[i][2][k]+x[i][4][k];

            x[i][0][k]=(a[0]+a[1])*s;
            x[i][1][k]=(a[0]-a[1])*s;
            x[i][2][k]=(a[2]+a[3])*s;
            x[i][3][k]=(a[2]-a[3])*s;
        }
        for(j=6;j<m;j+=4)
        {
            for(k=0;k<n;k++)
            {
                //b[0]=0.125*x[i][j-3][k]+x[i][j-1][k];
                b[k][1]=x[i][j+1][k]-0.125*x[i][j+3][k];
                //b[2]=-0.125*x[i][j-4][k]+x[i][j-2][k];
                b[k][3]=x[i][j][k]+0.125*x[i][j+2][k];

                a[0]=b[k][2]+0.125*b[k][3];
                a[1]=b[k][0]-0.125*b[k][1];
                a[2]=-0.125*b[k][2]+b[k][3];
                a[3]=0.125*b[k][0]+b[k][1];

                b[k][0]=0.125*x[i][j+1][k]+x[i][j+3][k];
                b[k][2]=-0.125*x[i][j][k]+x[i][j+2][k];

                x[i][j-2][k]=(a[0]+a[1])*s;
                x[i][j-1][k]=(a[0]-a[1])*s;
                x[i][j][k]=(a[2]+a[3])*s;
                x[i][j+1][k]=(a[2]-a[3])*s;
            }
        }
        for(k=0;k<n;k++)
        {
            //b[0]=-0.125*x[i][m-4][k]+x[i][m-2][k];
            //b[1]=0.125*x[i][m-3][k]+x[i][m-1][k];

            a[0]=b[k][2]+0.125*b[k][0];
            a[1]=-0.125*b[k][2]+b[k][0];

            x[i][m-2][k]=(a[0]+a[1])*s;
            x[i][m-1][k]=(a[0]-a[1])*s;
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void ODD_PTV_Column_1(float ***x,int m,int n)
{
    float a[4];
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float u,v;
    m+=1;
    for(i=0;i<96;i++)
    {
        if(m%4==0)
        {
            for(k=0; k<n; k++)
            {
                b[k][0]=x[i][0][k]+0.125*x[i][2][k];
                b[k][1]=x[i][1][k]-0.125*x[i][3][k];

                a[0]=b[k][0]-0.125*b[k][1];
                a[1]=0.125*b[k][0]+b[k][1];

                b[k][0]=0.125*x[i][1][k]+x[i][3][k];
                b[k][2]=-0.125*x[i][0][k]+x[i][2][k];

                x[i][0][k]=(a[0]+a[1])*s;
                x[i][1][k]=(a[0]-a[1])*s;
            }
            for(j=2; j<m-6; j+=4)
            {
                for(k=0; k<n; k++)
                {
                    //b[0]=0.125*x[i][j-1][k]+x[i][j+1][k];
                    b[k][1]=x[i][j+3][k]-0.125*x[i][j+5][k];

                    a[1]=b[k][0]-0.125*b[k][1];
                    a[3]=0.125*b[k][0]+b[k][1];

                    //b[2]=-0.125*x[i][j-2][k]+x[i][j][k];
                    b[k][3]=x[i][j+2][k]+0.125*x[i][j+4][k];

                    a[0]=b[k][2]+0.125*b[k][3];
                    a[2]=-0.125*b[k][2]+b[k][3];

                    b[k][0]=0.125*x[i][j+3][k]+x[i][j+5][k];
                    b[k][2]=-0.125*x[i][j+2][k]+x[i][j+4][k];

                    x[i][j][k]=(a[0]+a[1])*s;
                    x[i][j+1][k]=(a[0]-a[1])*s;
                    x[i][j+2][k]=(a[2]+a[3])*s;
                    x[i][j+3][k]=(a[2]-a[3])*s;
                }
            }
            for(k=0;k<n;k++)
            {
                //b[2]=-0.125*x[i][m-8][k]+x[i][m-6][k];
                b[k][1]=x[i][m-4][k]+0.125*x[i][m-2][k];
                b[k][3]=-0.125*x[i][m-4][k]+x[i][m-2][k];
                //b[0]=0.125*x[i][m-7][k]+x[i][m-5][k];

                //v=1.28571429*b[3];                             //v
                u=1.015625*x[i][m-3][k]-0.16071429*b[k][3];       //u

                a[0]=b[k][2]+0.125*b[k][1];
                a[1]=b[k][0]-0.125*u;
                a[2]=-0.125*b[k][2]+b[k][1];
                a[3]=0.125*b[k][0]+u;

                x[i][m-6][k]=(a[0]+a[1])*s;
                x[i][m-5][k]=(a[0]-a[1])*s;
                x[i][m-4][k]=(a[2]+a[3])*s;
                x[i][m-3][k]=(a[2]-a[3])*s;

                x[i][m-2][k]=1.16071429*b[k][3]*2*s;
            }
        }
        else
        {
            for(k=0; k<n; k++)
            {
                b[k][0]=x[i][0][k]-0.125*x[i][1][k];
                b[k][1]=0.125*x[i][0][k]+x[i][1][k];
                b[k][2]=x[i][3][k]-0.125*x[i][5][k];
                b[k][3]=x[i][2][k]+0.125*x[i][4][k];

                a[0]=b[k][0]+0.125*b[k][3];
                a[1]=b[k][1]-0.125*b[k][2];
                a[2]=-0.125*b[k][0]+b[k][3];
                a[3]=0.125*b[k][1]+b[k][2];

                b[k][0]=0.125*x[i][3][k]+x[i][5][k];
                b[k][2]=-0.125*x[i][2][k]+x[i][4][k];

                x[i][0][k]=(a[0]+a[1])*s;
                x[i][1][k]=(a[0]-a[1])*s;
                x[i][2][k]=(a[2]+a[3])*s;
                x[i][3][k]=(a[2]-a[3])*s;
            }
            for(j=6; j<m-4; j+=4)
            {
                for(k=0; k<n; k++)
                {
                    //b[0]=0.125*x[i][j-3][k]+x[i][j-1][k];
                    b[k][1]=x[i][j+1][k]-0.125*x[i][j+3][k];
                    //b[2]=-0.125*x[i][j-4][k]+x[i][j-2][k];
                    b[k][3]=x[i][j][k]+0.125*x[i][j+2][k];

                    a[0]=b[k][2]+0.125*b[k][3];
                    a[1]=b[k][0]-0.125*b[k][1];
                    a[2]=-0.125*b[k][2]+b[k][3];
                    a[3]=0.125*b[k][0]+b[k][1];

                    b[k][0]=0.125*x[i][j+1][k]+x[i][j+3][k];
                    b[k][2]=-0.125*x[i][j][k]+x[i][j+2][k];

                    x[i][j-2][k]=(a[0]+a[1])*s;
                    x[i][j-1][k]=(a[0]-a[1])*s;
                    x[i][j][k]=(a[2]+a[3])*s;
                    x[i][j+1][k]=(a[2]-a[3])*s;
                }
            }
            for(k=0;k<n;k++)
            {
                //b[2]=-0.125*x[i][m-8][k]+x[i][m-6][k];
                b[k][1]=x[i][m-4][k]+0.125*x[i][m-2][k];
                b[k][3]=-0.125*x[i][m-4][k]+x[i][m-2][k];
                //b[0]=0.125*x[i][m-7][k]+x[i][m-5][k];

                //v=1.28571429*b[3];                             //v
                u=1.015625*x[i][m-3][k]-0.16071429*b[k][3];       //u

                a[0]=b[k][2]+0.125*b[k][1];
                a[1]=b[k][0]-0.125*u;
                a[2]=-0.125*b[k][2]+b[k][1];
                a[3]=0.125*b[k][0]+u;

                x[i][m-6][k]=(a[0]+a[1])*s;
                x[i][m-5][k]=(a[0]-a[1])*s;
                x[i][m-4][k]=(a[2]+a[3])*s;
                x[i][m-3][k]=(a[2]-a[3])*s;

                x[i][m-2][k]=1.16071429*b[k][3]*2*s;
            }
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
//操作：     原址第一遍列PTV
//前置条件： x: 指向存放直流系数三维数组首地址,m:列长度；n:行宽度
//后置条件： 数据在原址上处理完成
void PTV_Column_1(float ***x,int m,int n)
{
    if(m%4==0)
    {
        PTV_4k_Column_1(x,m,n);
    }
    else if(m%4==2)
    {
        PTV_4k_2_Column_1(x,m,n);
    }
    else
    {
        ODD_PTV_Column_1(x,m,n);
    }
}
void IPTV_4k_Column_1(float ***x,int m,int n)
{
    float a[4];
    //float b[n][6];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 6);
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k++)
        {
            b[k][4]=(x[i][0][k]+x[i][1][k])*s;
            b[k][5]=(x[i][0][k]-x[i][1][k])*s;
            b[k][0]=(x[i][2][k]+x[i][3][k])*s;
            b[k][1]=(x[i][2][k]-x[i][3][k])*s;
            b[k][2]=(x[i][4][k]+x[i][5][k])*s;
            b[k][3]=(x[i][4][k]-x[i][5][k])*s;

            a[0]=b[k][4]+0.125*b[k][5];
            a[1]=b[k][0]-0.125*b[k][2];
            a[2]=-0.125*b[k][4]+b[k][5];
            a[3]=b[k][1]+0.125*b[k][3];

            x[i][0][k]=a[0]-0.125*a[1];
            x[i][1][k]=a[2]+0.125*a[3];
            x[i][2][k]=0.125*a[0]+a[1];
            x[i][3][k]=-0.125*a[2]+a[3];

        }
        for(j=4;j<m-4;j+=4)
        {
            for(k=0;k<n;k++)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=(x[i][j+2][k]+x[i][j+3][k])*s;
                b[k][1]=(x[i][j+2][k]-x[i][j+3][k])*s;
                b[k][2]=(x[i][j+4][k]+x[i][j+5][k])*s;
                b[k][3]=(x[i][j+4][k]-x[i][j+5][k])*s;

                a[1]=b[k][0]-0.125*b[k][2];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][j][k]=a[0]-0.125*a[1];
                x[i][j+1][k]=a[2]+0.125*a[3];
                x[i][j+2][k]=0.125*a[0]+a[1];
                x[i][j+3][k]=-0.125*a[2]+a[3];
            }
        }
        for(k=0;k<n;k++)
        {
            a[0]=0.125*b[k][0]+b[k][2];
            a[2]=-0.125*b[k][1]+b[k][3];

            b[k][0]=(x[i][m-2][k]+x[i][m-1][k])*s;
            b[k][1]=(x[i][m-2][k]-x[i][m-1][k])*s;

            a[1]=b[k][0]-0.125*b[k][1];
            a[3]=0.125*b[k][0]+b[k][1];

            x[i][m-4][k]=a[0]-0.125*a[1];
            x[i][m-3][k]=a[2]+0.125*a[3];
            x[i][m-2][k]=0.125*a[0]+a[1];
            x[i][m-1][k]=-0.125*a[2]+a[3];
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void IPTV_4k_2_Column_1(float ***x,int m,int n)
{
    float a[4];
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k++)
        {
            b[k][0]=(x[i][0][k]+x[i][1][k])*s;
            b[k][1]=(x[i][0][k]-x[i][1][k])*s;
            b[k][2]=(x[i][2][k]+x[i][3][k])*s;
            b[k][3]=(x[i][2][k]-x[i][3][k])*s;

            a[0]=b[k][0]-0.125*b[k][2];
            a[1]=b[k][1]+0.125*b[k][3];

            x[i][0][k]=a[0]+0.125*a[1];
            x[i][1][k]=-0.125*a[0]+a[1];
        }
        for(j=2;j<m-4;j+=4)
        {
            for(k=0;k<n;k++)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=(x[i][j+2][k]+x[i][j+3][k])*s;
                b[k][1]=(x[i][j+2][k]-x[i][j+3][k])*s;
                b[k][2]=(x[i][j+4][k]+x[i][j+5][k])*s;
                b[k][3]=(x[i][j+4][k]-x[i][j+5][k])*s;

                a[1]=b[k][0]-0.125*b[k][2];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][j][k]=a[0]-0.125*a[1];
                x[i][j+1][k]=a[2]+0.125*a[3];
                x[i][j+2][k]=0.125*a[0]+a[1];
                x[i][j+3][k]=-0.125*a[2]+a[3];
            }
        }
        for(k=0;k<n;k++)
        {
            a[0]=0.125*b[k][0]+b[k][2];
            a[2]=-0.125*b[k][1]+b[k][3];

            b[k][0]=(x[i][m-2][k]+x[i][m-1][k])*s;
            b[k][1]=(x[i][m-2][k]-x[i][m-1][k])*s;

            a[1]=b[k][0]-0.125*b[k][1];
            a[3]=0.125*b[k][0]+b[k][1];

            x[i][m-4][k]=a[0]-0.125*a[1];
            x[i][m-3][k]=a[2]+0.125*a[3];
            x[i][m-2][k]=0.125*a[0]+a[1];
            x[i][m-1][k]=-0.125*a[2]+a[3];
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void ODD_IPTV_Column_1(float ***x,int m,int n)
{
    float a[4];
    //float b[n][6];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 6);
    m+=1;
    for(i=0;i<96;i++)
    {
        if(m%4==0)
        {
            for(k=0; k<n; k++)
            {
                b[k][4]=(x[i][0][k]+x[i][1][k])*s;
                b[k][5]=(x[i][0][k]-x[i][1][k])*s;
                b[k][0]=(x[i][2][k]+x[i][3][k])*s;
                b[k][1]=(x[i][2][k]-x[i][3][k])*s;
                b[k][2]=(x[i][4][k]+x[i][5][k])*s;
                b[k][3]=(x[i][4][k]-x[i][5][k])*s;

                a[0]=b[k][4]+0.125*b[k][5];
                a[1]=b[k][0]-0.125*b[k][2];
                a[2]=-0.125*b[k][4]+b[k][5];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][0][k]=a[0]-0.125*a[1];
                x[i][1][k]=a[2]+0.125*a[3];
                x[i][2][k]=0.125*a[0]+a[1];
                x[i][3][k]=-0.125*a[2]+a[3];
            }
            for(j=4; j<m-4; j+=4)
            {
                for(k=0; k<n; k++)
                {
                    a[0]=0.125*b[k][0]+b[k][2];
                    a[2]=-0.125*b[k][1]+b[k][3];

                    b[k][0]=(x[i][j+2][k]+x[i][j+3][k])*s;
                    b[k][1]=(x[i][j+2][k]-x[i][j+3][k])*s;
                    b[k][2]=(x[i][j+4][k]+x[i][j+5][k])*s;
                    b[k][3]=(x[i][j+4][k]-x[i][j+5][k])*s;

                    a[1]=b[k][0]-0.125*b[k][2];
                    a[3]=b[k][1]+0.125*b[k][3];

                    x[i][j][k]=a[0]-0.125*a[1];
                    x[i][j+1][k]=a[2]+0.125*a[3];
                    x[i][j+2][k]=0.125*a[0]+a[1];
                    x[i][j+3][k]=-0.125*a[2]+a[3];
                }
            }
            for(k=0; k<n; k++)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=b[k][1]=x[i][m-2][k]*s;

                a[1]=b[k][0]-0.125*b[k][1];
                a[3]=0.125*b[k][0]+b[k][1];

                x[i][m-4][k]=a[0]-0.125*a[1];
                x[i][m-3][k]=a[2]+0.125*a[3];
                x[i][m-2][k]=0.125*a[0]+a[1];
            }
        }
        else
        {
            for(k=0; k<n; k++)
            {
                b[k][0]=(x[i][0][k]+x[i][1][k])*s;
                b[k][1]=(x[i][0][k]-x[i][1][k])*s;
                b[k][2]=(x[i][2][k]+x[i][3][k])*s;
                b[k][3]=(x[i][2][k]-x[i][3][k])*s;

                a[0]=b[k][0]-0.125*b[k][2];
                a[1]=b[k][1]+0.125*b[k][3];

                x[i][0][k]=a[0]+0.125*a[1];
                x[i][1][k]=-0.125*a[0]+a[1];
            }
            for(j=2; j<m-4; j+=4)
            {
                for(k=0; k<n; k++)
                {
                    a[0]=0.125*b[k][0]+b[k][2];
                    a[2]=-0.125*b[k][1]+b[k][3];

                    b[k][0]=(x[i][j+2][k]+x[i][j+3][k])*s;
                    b[k][1]=(x[i][j+2][k]-x[i][j+3][k])*s;
                    b[k][2]=(x[i][j+4][k]+x[i][j+5][k])*s;
                    b[k][3]=(x[i][j+4][k]-x[i][j+5][k])*s;

                    a[1]=b[k][0]-0.125*b[k][2];
                    a[3]=b[k][1]+0.125*b[k][3];

                    x[i][j][k]=a[0]-0.125*a[1];
                    x[i][j+1][k]=a[2]+0.125*a[3];
                    x[i][j+2][k]=0.125*a[0]+a[1];
                    x[i][j+3][k]=-0.125*a[2]+a[3];
                }
             }
             for(k=0;k<n;k++)
             {
                 a[0]=0.125*b[k][0]+b[k][2];
                 a[2]=-0.125*b[k][1]+b[k][3];

                 b[k][0]=b[k][1]=x[i][m-2][k]*s;

                 a[1]=b[k][0]-0.125*b[k][1];
                 a[3]=0.125*b[k][0]+b[k][1];

                 x[i][m-4][k]=a[0]-0.125*a[1];
                 x[i][m-3][k]=a[2]+0.125*a[3];
                 x[i][m-2][k]=0.125*a[0]+a[1];
             }
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
//操作：     原址第一遍列IPTV
//前置条件： x: 指向存放直流系数三维数组首地址,m:列长度；n:行宽度
//后置条件： 数据在原址上处理完成
void IPTV_Column_1(float ***x,int m,int n)
{
    if(m%4==0)
    {
        IPTV_4k_Column_1(x,m,n);
    }
    else if(m%4==2)
    {
        IPTV_4k_2_Column_1(x,m,n);
    }
    else
    {
        ODD_IPTV_Column_1(x,m,n);
    }
}
void PTV_4k_Column_2 (float ***x,int m,int n)
{
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float a[4];
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k+=2)
        {
            b[k][0]=x[i][0][k]+0.125*x[i][4][k];
            b[k][1]=x[i][2][k]-0.125*x[i][6][k];

            a[0]=b[k][0]-0.125*b[k][1];
            a[1]=0.125*b[k][0]+b[k][1];

            b[k][0]=0.125*x[i][2][k]+x[i][6][k];
            b[k][2]=-0.125*x[i][0][k]+x[i][4][k];

            x[i][0][k]=(a[0]+a[1])*s;
            x[i][2][k]=(a[0]-a[1])*s;
        }
        for(j=4;j<m-4;j+=8)
        {
            for(k=0;k<n;k+=2)
            {
                //b[0]=0.125*x[i][j-1][k]+x[i][j+1][k];
                b[k][1]=x[i][j+6][k]-0.125*x[i][j+10][k];

                a[1]=b[k][0]-0.125*b[k][1];
                a[3]=0.125*b[k][0]+b[k][1];

                //b[2]=-0.125*x[i][j-2][k]+x[i][j][k];
                b[k][3]=x[i][j+4][k]+0.125*x[i][j+8][k];

                a[0]=b[k][2]+0.125*b[k][3];
                a[2]=-0.125*b[k][2]+b[k][3];

                b[k][0]=0.125*x[i][j+6][k]+x[i][j+10][k];
                b[k][2]=-0.125*x[i][j+4][k]+x[i][j+8][k];

                x[i][j][k]=(a[0]+a[1])*s;
                x[i][j+2][k]=(a[0]-a[1])*s;
                x[i][j+4][k]=(a[2]+a[3])*s;
                x[i][j+6][k]=(a[2]-a[3])*s;
            }
        }
        for(k=0;k<n;k+=2)
        {
//            printf("%f\n",b[0]);
//            printf("%f\n",b[2]);

            a[0]=b[k][2]+0.125*b[k][0];
            a[1]=-0.125*b[k][2]+b[k][0];

            x[i][m-4][k]=(a[0]+a[1])*s;
            x[i][m-2][k]=(a[0]-a[1])*s;
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void PTV_4k_2_Column_2(float ***x,int m,int n)
{
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float a[4];
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k+=2)
        {
            b[k][0]=x[i][0][k]-0.125*x[i][2][k];
            b[k][1]=0.125*x[i][0][k]+x[i][2][k];
            b[k][2]=x[i][6][k]-0.125*x[i][10][k];
            b[k][3]=x[i][4][k]+0.125*x[i][8][k];

            a[0]=b[k][0]+0.125*b[k][3];
            a[1]=b[k][1]-0.125*b[k][2];
            a[2]=-0.125*b[k][0]+b[k][3];
            a[3]=0.125*b[k][1]+b[k][2];

            b[k][0]=0.125*x[i][6][k]+x[i][10][k];
            b[k][2]=-0.125*x[i][4][k]+x[i][8][k];

            x[i][0][k]=(a[0]+a[1])*s;
            x[i][2][k]=(a[0]-a[1])*s;
            x[i][4][k]=(a[2]+a[3])*s;
            x[i][6][k]=(a[2]-a[3])*s;
        }
        for(j=12;j<m;j+=8)
        {
            for(k=0;k<n;k+=2)
            {
                //b[0]=0.125*x[i][j-3][k]+x[i][j-1][k];
                b[k][1]=x[i][j+2][k]-0.125*x[i][j+6][k];
                //b[2]=-0.125*x[i][j-4][k]+x[i][j-2][k];
                b[k][3]=x[i][j][k]+0.125*x[i][j+4][k];

                a[0]=b[k][2]+0.125*b[k][3];
                a[1]=b[k][0]-0.125*b[k][1];
                a[2]=-0.125*b[k][2]+b[k][3];
                a[3]=0.125*b[k][0]+b[k][1];

                b[k][0]=0.125*x[i][j+2][k]+x[i][j+6][k];
                b[k][2]=-0.125*x[i][j][k]+x[i][j+4][k];

                x[i][j-4][k]=(a[0]+a[1])*s;
                x[i][j-2][k]=(a[0]-a[1])*s;
                x[i][j][k]=(a[2]+a[3])*s;
                x[i][j+2][k]=(a[2]-a[3])*s;
            }
        }
        for(k=0;k<n;k+=2)
        {
            //b[0]=-0.125*x[i][m-4][k]+x[i][m-2][k];
            //b[1]=0.125*x[i][m-3][k]+x[i][m-1][k];

            a[0]=b[k][2]+0.125*b[k][0];
            a[1]=-0.125*b[k][2]+b[k][0];

            x[i][m-4][k]=(a[0]+a[1])*s;
            x[i][m-2][k]=(a[0]-a[1])*s;
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void ODD_PTV_Column_2(float ***x,int m,int n)
{
    float a[4];
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float u,v;
    m+=2;
    for(i=0;i<96;i++)
    {
        if(m%8==0)
        {
            for(k=0; k<n; k+=2)
            {
                b[k][0]=x[i][0][k]+0.125*x[i][4][k];
                b[k][1]=x[i][2][k]-0.125*x[i][6][k];

                a[0]=b[k][0]-0.125*b[k][1];
                a[1]=0.125*b[k][0]+b[k][1];

                b[k][0]=0.125*x[i][2][k]+x[i][6][k];
                b[k][2]=-0.125*x[i][0][k]+x[i][4][k];

                x[i][0][k]=(a[0]+a[1])*s;
                x[i][2][k]=(a[0]-a[1])*s;
            }
            for(j=4; j<m-12; j+=8)
            {
                for(k=0; k<n; k+=2)
                {
                    //b[0]=0.125*x[i][j-1][k]+x[i][j+1][k];
                    b[k][1]=x[i][j+6][k]-0.125*x[i][j+10][k];

                    a[1]=b[k][0]-0.125*b[k][1];
                    a[3]=0.125*b[k][0]+b[k][1];

                    //b[2]=-0.125*x[i][j-2][k]+x[i][j][k];
                    b[k][3]=x[i][j+4][k]+0.125*x[i][j+8][k];

                    a[0]=b[k][2]+0.125*b[k][3];
                    a[2]=-0.125*b[k][2]+b[k][3];

                    b[k][0]=0.125*x[i][j+6][k]+x[i][j+10][k];
                    b[k][2]=-0.125*x[i][j+4][k]+x[i][j+8][k];

                    x[i][j][k]=(a[0]+a[1])*s;
                    x[i][j+2][k]=(a[0]-a[1])*s;
                    x[i][j+4][k]=(a[2]+a[3])*s;
                    x[i][j+6][k]=(a[2]-a[3])*s;
                }
            }
            for(k=0;k<n;k+=2)
            {
                //b[2]=-0.125*x[i][m-8][k]+x[i][m-6][k];
                b[k][1]=x[i][m-8][k]+0.125*x[i][m-4][k];
                b[k][3]=-0.125*x[i][m-8][k]+x[i][m-4][k];
                //b[0]=0.125*x[i][m-7][k]+x[i][m-5][k];

                //v=1.28571429*b[3];                             //v
                u=1.015625*x[i][m-6][k]-0.16071429*b[k][3];       //u

                a[0]=b[k][2]+0.125*b[k][1];
                a[1]=b[k][0]-0.125*u;
                a[2]=-0.125*b[k][2]+b[k][1];
                a[3]=0.125*b[k][0]+u;

                x[i][m-12][k]=(a[0]+a[1])*s;
                x[i][m-10][k]=(a[0]-a[1])*s;
                x[i][m-8][k]=(a[2]+a[3])*s;
                x[i][m-6][k]=(a[2]-a[3])*s;

                x[i][m-4][k]=1.16071429*b[k][3]*2*s;
            }
        }
        else
        {
            for(k=0; k<n; k+=2)
            {
                b[k][0]=x[i][0][k]-0.125*x[i][2][k];
                b[k][1]=0.125*x[i][0][k]+x[i][2][k];
                b[k][2]=x[i][6][k]-0.125*x[i][10][k];
                b[k][3]=x[i][4][k]+0.125*x[i][8][k];

                a[0]=b[k][0]+0.125*b[k][3];
                a[1]=b[k][1]-0.125*b[k][2];
                a[2]=-0.125*b[k][0]+b[k][3];
                a[3]=0.125*b[k][1]+b[k][2];

                b[k][0]=0.125*x[i][6][k]+x[i][10][k];
                b[k][2]=-0.125*x[i][4][k]+x[i][8][k];

                x[i][0][k]=(a[0]+a[1])*s;
                x[i][2][k]=(a[0]-a[1])*s;
                x[i][4][k]=(a[2]+a[3])*s;
                x[i][6][k]=(a[2]-a[3])*s;
            }
            for(j=12; j<m-8; j+=8)
            {
                for(k=0; k<n; k+=2)
                {
                    //b[0]=0.125*x[i][j-3][k]+x[i][j-1][k];
                    b[k][1]=x[i][j+2][k]-0.125*x[i][j+6][k];
                    //b[2]=-0.125*x[i][j-4][k]+x[i][j-2][k];
                    b[k][3]=x[i][j][k]+0.125*x[i][j+4][k];

                    a[0]=b[k][2]+0.125*b[k][3];
                    a[1]=b[k][0]-0.125*b[k][1];
                    a[2]=-0.125*b[k][2]+b[k][3];
                    a[3]=0.125*b[k][0]+b[k][1];

                    b[k][0]=0.125*x[i][j+2][k]+x[i][j+6][k];
                    b[k][2]=-0.125*x[i][j][k]+x[i][j+4][k];

                    x[i][j-4][k]=(a[0]+a[1])*s;
                    x[i][j-2][k]=(a[0]-a[1])*s;
                    x[i][j][k]=(a[2]+a[3])*s;
                    x[i][j+2][k]=(a[2]-a[3])*s;
                }
            }
            for(k=0;k<n;k+=2)
            {
                //b[2]=-0.125*x[i][m-8][k]+x[i][m-6][k];
                b[k][1]=x[i][m-8][k]+0.125*x[i][m-4][k];
                b[k][3]=-0.125*x[i][m-8][k]+x[i][m-4][k];
                //b[0]=0.125*x[i][m-7][k]+x[i][m-5][k];

                //v=1.28571429*b[3];                             //v
                u=1.015625*x[i][m-6][k]-0.16071429*b[k][3];       //u

                a[0]=b[k][2]+0.125*b[k][1];
                a[1]=b[k][0]-0.125*u;
                a[2]=-0.125*b[k][2]+b[k][1];
                a[3]=0.125*b[k][0]+u;

                x[i][m-12][k]=(a[0]+a[1])*s;
                x[i][m-10][k]=(a[0]-a[1])*s;
                x[i][m-8][k]=(a[2]+a[3])*s;
                x[i][m-6][k]=(a[2]-a[3])*s;

                x[i][m-4][k]=1.16071429*b[k][3]*2*s;
            }
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
//操作：     原址第二遍列PTV
//前置条件： x: 指向存放直流系数三维数组首地址,m:列长度；n:行宽度
//后置条件： 数据在原址上处理完成
void PTV_Column_2(float ***x,int m,int n)
{
    if(m%8==0)
    {
        PTV_4k_Column_2(x,m,n);
    }
    else if(m%8==4)
    {
        PTV_4k_2_Column_2(x,m,n);
    }
    else
    {
        ODD_PTV_Column_2(x,m,n);
    }
}
void IPTV_4k_Column_2(float ***x,int m,int n)
{
    float a[4];
    //float b[n][6];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 6);
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k+=2)
        {
            b[k][4]=(x[i][0][k]+x[i][2][k])*s;
            b[k][5]=(x[i][0][k]-x[i][2][k])*s;
            b[k][0]=(x[i][4][k]+x[i][6][k])*s;
            b[k][1]=(x[i][4][k]-x[i][6][k])*s;
            b[k][2]=(x[i][8][k]+x[i][10][k])*s;
            b[k][3]=(x[i][8][k]-x[i][10][k])*s;

            a[0]=b[k][4]+0.125*b[k][5];
            a[1]=b[k][0]-0.125*b[k][2];
            a[2]=-0.125*b[k][4]+b[k][5];
            a[3]=b[k][1]+0.125*b[k][3];

            x[i][0][k]=a[0]-0.125*a[1];
            x[i][2][k]=a[2]+0.125*a[3];
            x[i][4][k]=0.125*a[0]+a[1];
            x[i][6][k]=-0.125*a[2]+a[3];

        }
        for(j=8;j<m-8;j+=8)
        {
            for(k=0;k<n;k+=2)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=(x[i][j+4][k]+x[i][j+6][k])*s;
                b[k][1]=(x[i][j+4][k]-x[i][j+6][k])*s;
                b[k][2]=(x[i][j+8][k]+x[i][j+10][k])*s;
                b[k][3]=(x[i][j+8][k]-x[i][j+10][k])*s;

                a[1]=b[k][0]-0.125*b[k][2];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][j][k]=a[0]-0.125*a[1];
                x[i][j+2][k]=a[2]+0.125*a[3];
                x[i][j+4][k]=0.125*a[0]+a[1];
                x[i][j+6][k]=-0.125*a[2]+a[3];
            }
        }
        for(k=0;k<n;k+=2)
        {
            a[0]=0.125*b[k][0]+b[k][2];
            a[2]=-0.125*b[k][1]+b[k][3];

            b[k][0]=(x[i][m-4][k]+x[i][m-2][k])*s;
            b[k][1]=(x[i][m-4][k]-x[i][m-2][k])*s;

            a[1]=b[k][0]-0.125*b[k][1];
            a[3]=0.125*b[k][0]+b[k][1];

            x[i][m-8][k]=a[0]-0.125*a[1];
            x[i][m-6][k]=a[2]+0.125*a[3];
            x[i][m-4][k]=0.125*a[0]+a[1];
            x[i][m-2][k]=-0.125*a[2]+a[3];
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void IPTV_4k_2_Column_2(float ***x,int m,int n)
{
    float a[4];
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    for(i=0;i<96;i++)
    {
        for(k=0;k<n;k+=2)
        {
            b[k][0]=(x[i][0][k]+x[i][2][k])*s;
            b[k][1]=(x[i][0][k]-x[i][2][k])*s;
            b[k][2]=(x[i][4][k]+x[i][6][k])*s;
            b[k][3]=(x[i][4][k]-x[i][6][k])*s;

            a[0]=b[k][0]-0.125*b[k][2];
            a[1]=b[k][1]+0.125*b[k][3];

            x[i][0][k]=a[0]+0.125*a[1];
            x[i][2][k]=-0.125*a[0]+a[1];
        }
        for(j=4;j<m-8;j+=8)
        {
            for(k=0;k<n;k+=2)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=(x[i][j+4][k]+x[i][j+6][k])*s;
                b[k][1]=(x[i][j+4][k]-x[i][j+6][k])*s;
                b[k][2]=(x[i][j+8][k]+x[i][j+10][k])*s;
                b[k][3]=(x[i][j+8][k]-x[i][j+10][k])*s;

                a[1]=b[k][0]-0.125*b[k][2];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][j][k]=a[0]-0.125*a[1];
                x[i][j+2][k]=a[2]+0.125*a[3];
                x[i][j+4][k]=0.125*a[0]+a[1];
                x[i][j+6][k]=-0.125*a[2]+a[3];
            }
        }
        for(k=0;k<n;k+=2)
        {
            a[0]=0.125*b[k][0]+b[k][2];
            a[2]=-0.125*b[k][1]+b[k][3];

            b[k][0]=(x[i][m-4][k]+x[i][m-2][k])*s;
            b[k][1]=(x[i][m-4][k]-x[i][m-2][k])*s;

            a[1]=b[k][0]-0.125*b[k][1];
            a[3]=0.125*b[k][0]+b[k][1];

            x[i][m-8][k]=a[0]-0.125*a[1];
            x[i][m-6][k]=a[2]+0.125*a[3];
            x[i][m-4][k]=0.125*a[0]+a[1];
            x[i][m-2][k]=-0.125*a[2]+a[3];
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void ODD_IPTV_Column_2(float ***x,int m,int n)
{
    float a[4];
    //float b[n][6];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 6);
    m+=2;
    for(i=0;i<96;i++)
    {
        if(m%8==0)
        {
            for(k=0; k<n; k+=2)
            {
                b[k][4]=(x[i][0][k]+x[i][2][k])*s;
                b[k][5]=(x[i][0][k]-x[i][2][k])*s;
                b[k][0]=(x[i][4][k]+x[i][6][k])*s;
                b[k][1]=(x[i][4][k]-x[i][6][k])*s;
                b[k][2]=(x[i][8][k]+x[i][10][k])*s;
                b[k][3]=(x[i][8][k]-x[i][10][k])*s;

                a[0]=b[k][4]+0.125*b[k][5];
                a[1]=b[k][0]-0.125*b[k][2];
                a[2]=-0.125*b[k][4]+b[k][5];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][0][k]=a[0]-0.125*a[1];
                x[i][2][k]=a[2]+0.125*a[3];
                x[i][4][k]=0.125*a[0]+a[1];
                x[i][6][k]=-0.125*a[2]+a[3];
            }
            for(j=8; j<m-8; j+=8)
            {
                for(k=0; k<n; k+=2)
                {
                    a[0]=0.125*b[k][0]+b[k][2];
                    a[2]=-0.125*b[k][1]+b[k][3];

                    b[k][0]=(x[i][j+4][k]+x[i][j+6][k])*s;
                    b[k][1]=(x[i][j+4][k]-x[i][j+6][k])*s;
                    b[k][2]=(x[i][j+8][k]+x[i][j+10][k])*s;
                    b[k][3]=(x[i][j+8][k]-x[i][j+10][k])*s;

                    a[1]=b[k][0]-0.125*b[k][2];
                    a[3]=b[k][1]+0.125*b[k][3];

                    x[i][j][k]=a[0]-0.125*a[1];
                    x[i][j+2][k]=a[2]+0.125*a[3];
                    x[i][j+4][k]=0.125*a[0]+a[1];
                    x[i][j+6][k]=-0.125*a[2]+a[3];
                }
            }
            for(k=0; k<n; k+=2)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=b[k][1]=x[i][m-4][k]*s;

                a[1]=b[k][0]-0.125*b[k][1];
                a[3]=0.125*b[k][0]+b[k][1];

                x[i][m-8][k]=a[0]-0.125*a[1];
                x[i][m-6][k]=a[2]+0.125*a[3];
                x[i][m-4][k]=0.125*a[0]+a[1];
            }
        }
        else
        {
            for(k=0; k<n; k+=2)
            {
                b[k][0]=(x[i][0][k]+x[i][2][k])*s;
                b[k][1]=(x[i][0][k]-x[i][2][k])*s;
                b[k][2]=(x[i][4][k]+x[i][6][k])*s;
                b[k][3]=(x[i][4][k]-x[i][6][k])*s;

                a[0]=b[k][0]-0.125*b[k][2];
                a[1]=b[k][1]+0.125*b[k][3];

                x[i][0][k]=a[0]+0.125*a[1];
                x[i][2][k]=-0.125*a[0]+a[1];
            }
            for(j=4; j<m-8; j+=8)
            {
                for(k=0; k<n; k+=2)
                {
                    a[0]=0.125*b[k][0]+b[k][2];
                    a[2]=-0.125*b[k][1]+b[k][3];

                    b[k][0]=(x[i][j+4][k]+x[i][j+6][k])*s;
                    b[k][1]=(x[i][j+4][k]-x[i][j+6][k])*s;
                    b[k][2]=(x[i][j+8][k]+x[i][j+10][k])*s;
                    b[k][3]=(x[i][j+8][k]-x[i][j+10][k])*s;

                    a[1]=b[k][0]-0.125*b[k][2];
                    a[3]=b[k][1]+0.125*b[k][3];

                    x[i][j][k]=a[0]-0.125*a[1];
                    x[i][j+2][k]=a[2]+0.125*a[3];
                    x[i][j+4][k]=0.125*a[0]+a[1];
                    x[i][j+6][k]=-0.125*a[2]+a[3];
                }
             }
             for(k=0;k<n;k+=2)
             {
                 a[0]=0.125*b[k][0]+b[k][2];
                 a[2]=-0.125*b[k][1]+b[k][3];

                 b[k][0]=b[k][1]=x[i][m-4][k]*s;

                 a[1]=b[k][0]-0.125*b[k][1];
                 a[3]=0.125*b[k][0]+b[k][1];

                 x[i][m-8][k]=a[0]-0.125*a[1];
                 x[i][m-6][k]=a[2]+0.125*a[3];
                 x[i][m-4][k]=0.125*a[0]+a[1];
             }
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
//操作：     原址第二遍列IPTV
//前置条件： x: 指向存放直流系数三维数组首地址,m:列长度；n:行宽度
//后置条件： 数据在原址上处理完成
void IPTV_Column_2(float ***x,int m,int n)
{
    if(m%8==0)
    {
        IPTV_4k_Column_2(x,m,n);
    }
    else if(m%8==4)
    {
        IPTV_4k_2_Column_2(x,m,n);
    }
    else
    {
        ODD_IPTV_Column_2(x,m,n);
    }
}
void PTV_4k_Column_3(float ***x,int m,int n)
{
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float a[4];
    for(i=0;i<96;i+=8)
    {
        for(k=0;k<n;k+=4)
        {
            b[k][0]=x[i][0][k]+0.125*x[i][8][k];
            b[k][1]=x[i][4][k]-0.125*x[i][12][k];

            a[0]=b[k][0]-0.125*b[k][1];
            a[1]=0.125*b[k][0]+b[k][1];

            b[k][0]=0.125*x[i][4][k]+x[i][12][k];
            b[k][2]=-0.125*x[i][0][k]+x[i][8][k];

            x[i][0][k]=(a[0]+a[1])*s;
            x[i][4][k]=(a[0]-a[1])*s;
        }
        for(j=8;j<m-8;j+=16)
        {
            for(k=0;k<n;k+=4)
            {
                //b[0]=0.125*x[i][j-1][k]+x[i][j+1][k];
                b[k][1]=x[i][j+12][k]-0.125*x[i][j+20][k];

                a[1]=b[k][0]-0.125*b[k][1];
                a[3]=0.125*b[k][0]+b[k][1];

                //b[2]=-0.125*x[i][j-2][k]+x[i][j][k];
                b[k][3]=x[i][j+8][k]+0.125*x[i][j+16][k];

                a[0]=b[k][2]+0.125*b[k][3];
                a[2]=-0.125*b[k][2]+b[k][3];

                b[k][0]=0.125*x[i][j+12][k]+x[i][j+20][k];
                b[k][2]=-0.125*x[i][j+8][k]+x[i][j+16][k];

                x[i][j][k]=(a[0]+a[1])*s;
                x[i][j+4][k]=(a[0]-a[1])*s;
                x[i][j+8][k]=(a[2]+a[3])*s;
                x[i][j+12][k]=(a[2]-a[3])*s;
            }
        }
        for(k=0;k<n;k+=4)
        {
//            printf("%f\n",b[0]);
//            printf("%f\n",b[2]);

            a[0]=b[k][2]+0.125*b[k][0];
            a[1]=-0.125*b[k][2]+b[k][0];

            x[i][m-8][k]=(a[0]+a[1])*s;
            x[i][m-4][k]=(a[0]-a[1])*s;
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void PTV_4k_2_Column_3(float ***x,int m,int n)
{
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float a[4];
    for(i=0;i<96;i+=8)
    {
        for(k=0;k<n;k+=4)
        {
            b[k][0]=x[i][0][k]-0.125*x[i][4][k];
            b[k][1]=0.125*x[i][0][k]+x[i][4][k];
            b[k][2]=x[i][12][k]-0.125*x[i][20][k];
            b[k][3]=x[i][8][k]+0.125*x[i][16][k];

            a[0]=b[k][0]+0.125*b[k][3];
            a[1]=b[k][1]-0.125*b[k][2];
            a[2]=-0.125*b[k][0]+b[k][3];
            a[3]=0.125*b[k][1]+b[k][2];

            b[k][0]=0.125*x[i][12][k]+x[i][20][k];
            b[k][2]=-0.125*x[i][8][k]+x[i][16][k];

            x[i][0][k]=(a[0]+a[1])*s;
            x[i][4][k]=(a[0]-a[1])*s;
            x[i][8][k]=(a[2]+a[3])*s;
            x[i][12][k]=(a[2]-a[3])*s;
        }
        for(j=24;j<m;j+=16)
        {
            for(k=0;k<n;k+=4)
            {
                //b[0]=0.125*x[i][j-3][k]+x[i][j-1][k];
                b[k][1]=x[i][j+4][k]-0.125*x[i][j+12][k];
                //b[2]=-0.125*x[i][j-4][k]+x[i][j-2][k];
                b[k][3]=x[i][j][k]+0.125*x[i][j+8][k];

                a[0]=b[k][2]+0.125*b[k][3];
                a[1]=b[k][0]-0.125*b[k][1];
                a[2]=-0.125*b[k][2]+b[k][3];
                a[3]=0.125*b[k][0]+b[k][1];

                b[k][0]=0.125*x[i][j+4][k]+x[i][j+12][k];
                b[k][2]=-0.125*x[i][j][k]+x[i][j+8][k];

                x[i][j-8][k]=(a[0]+a[1])*s;
                x[i][j-4][k]=(a[0]-a[1])*s;
                x[i][j][k]=(a[2]+a[3])*s;
                x[i][j+4][k]=(a[2]-a[3])*s;
            }
        }
        for(k=0;k<n;k+=4)
        {
            //b[0]=-0.125*x[i][m-4][k]+x[i][m-2][k];
            //b[1]=0.125*x[i][m-3][k]+x[i][m-1][k];

            a[0]=b[k][2]+0.125*b[k][0];
            a[1]=-0.125*b[k][2]+b[k][0];

            x[i][m-8][k]=(a[0]+a[1])*s;
            x[i][m-4][k]=(a[0]-a[1])*s;
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void ODD_PTV_Column_3(float ***x,int m,int n)
{
    float a[4];
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    float u,v;
    m+=4;
    for(i=0;i<96;i+=8)
    {
        if(m%16==0)
        {
            for(k=0; k<n; k+=4)
            {
                b[k][0]=x[i][0][k]+0.125*x[i][8][k];
                b[k][1]=x[i][4][k]-0.125*x[i][12][k];

                a[0]=b[k][0]-0.125*b[k][1];
                a[1]=0.125*b[k][0]+b[k][1];

                b[k][0]=0.125*x[i][4][k]+x[i][12][k];
                b[k][2]=-0.125*x[i][0][k]+x[i][8][k];

                x[i][0][k]=(a[0]+a[1])*s;
                x[i][4][k]=(a[0]-a[1])*s;
            }
            for(j=8; j<m-24; j+=16)
            {
                for(k=0; k<n; k+=4)
                {
                    //b[0]=0.125*x[i][j-1][k]+x[i][j+1][k];
                    b[k][1]=x[i][j+12][k]-0.125*x[i][j+20][k];

                    a[1]=b[k][0]-0.125*b[k][1];
                    a[3]=0.125*b[k][0]+b[k][1];

                    //b[2]=-0.125*x[i][j-2][k]+x[i][j][k];
                    b[k][3]=x[i][j+8][k]+0.125*x[i][j+16][k];

                    a[0]=b[k][2]+0.125*b[k][3];
                    a[2]=-0.125*b[k][2]+b[k][3];

                    b[k][0]=0.125*x[i][j+12][k]+x[i][j+20][k];
                    b[k][2]=-0.125*x[i][j+8][k]+x[i][j+16][k];

                    x[i][j][k]=(a[0]+a[1])*s;
                    x[i][j+4][k]=(a[0]-a[1])*s;
                    x[i][j+8][k]=(a[2]+a[3])*s;
                    x[i][j+12][k]=(a[2]-a[3])*s;
                }
            }
            for(k=0;k<n;k+=4)
            {
                //b[2]=-0.125*x[i][m-8][k]+x[i][m-6][k];
                b[k][1]=x[i][m-16][k]+0.125*x[i][m-8][k];
                b[k][3]=-0.125*x[i][m-16][k]+x[i][m-8][k];
                //b[0]=0.125*x[i][m-7][k]+x[i][m-5][k];

                //v=1.28571429*b[3];                             //v
                u=1.015625*x[i][m-12][k]-0.16071429*b[k][3];     //u

                a[0]=b[k][2]+0.125*b[k][1];
                a[1]=b[k][0]-0.125*u;
                a[2]=-0.125*b[k][2]+b[k][1];
                a[3]=0.125*b[k][0]+u;

                x[i][m-24][k]=(a[0]+a[1])*s;
                x[i][m-20][k]=(a[0]-a[1])*s;
                x[i][m-16][k]=(a[2]+a[3])*s;
                x[i][m-12][k]=(a[2]-a[3])*s;

                x[i][m-8][k]=1.16071429*b[k][3]*2*s;
            }
        }
        else
        {
            for(k=0; k<n; k+=4)
            {
                b[k][0]=x[i][0][k]-0.125*x[i][4][k];
                b[k][1]=0.125*x[i][0][k]+x[i][4][k];
                b[k][2]=x[i][12][k]-0.125*x[i][20][k];
                b[k][3]=x[i][8][k]+0.125*x[i][16][k];

                a[0]=b[k][0]+0.125*b[k][3];
                a[1]=b[k][1]-0.125*b[k][2];
                a[2]=-0.125*b[k][0]+b[k][3];
                a[3]=0.125*b[k][1]+b[k][2];

                b[k][0]=0.125*x[i][12][k]+x[i][20][k];
                b[k][2]=-0.125*x[i][8][k]+x[i][16][k];

                x[i][0][k]=(a[0]+a[1])*s;
                x[i][4][k]=(a[0]-a[1])*s;
                x[i][8][k]=(a[2]+a[3])*s;
                x[i][12][k]=(a[2]-a[3])*s;
            }
            for(j=24; j<m-16; j+=16)
            {
                for(k=0; k<n; k+=4)
                {
                    //b[0]=0.125*x[i][j-3][k]+x[i][j-1][k];
                    b[k][1]=x[i][j+4][k]-0.125*x[i][j+12][k];
                    //b[2]=-0.125*x[i][j-4][k]+x[i][j-2][k];
                    b[k][3]=x[i][j][k]+0.125*x[i][j+8][k];

                    a[0]=b[k][2]+0.125*b[k][3];
                    a[1]=b[k][0]-0.125*b[k][1];
                    a[2]=-0.125*b[k][2]+b[k][3];
                    a[3]=0.125*b[k][0]+b[k][1];

                    b[k][0]=0.125*x[i][j+4][k]+x[i][j+12][k];
                    b[k][2]=-0.125*x[i][j][k]+x[i][j+8][k];

                    x[i][j-8][k]=(a[0]+a[1])*s;
                    x[i][j-4][k]=(a[0]-a[1])*s;
                    x[i][j][k]=(a[2]+a[3])*s;
                    x[i][j+4][k]=(a[2]-a[3])*s;
                }
            }
            for(k=0;k<n;k+=4)
            {
                //b[2]=-0.125*x[i][m-8][k]+x[i][m-6][k];
                b[k][1]=x[i][m-16][k]+0.125*x[i][m-8][k];
                b[k][3]=-0.125*x[i][m-16][k]+x[i][m-8][k];
                //b[0]=0.125*x[i][m-7][k]+x[i][m-5][k];

                //v=1.28571429*b[3];                             //v
                u=1.015625*x[i][m-12][k]-0.16071429*b[k][3];       //u

                a[0]=b[k][2]+0.125*b[k][1];
                a[1]=b[k][0]-0.125*u;
                a[2]=-0.125*b[k][2]+b[k][1];
                a[3]=0.125*b[k][0]+u;

                x[i][m-24][k]=(a[0]+a[1])*s;
                x[i][m-20][k]=(a[0]-a[1])*s;
                x[i][m-16][k]=(a[2]+a[3])*s;
                x[i][m-12][k]=(a[2]-a[3])*s;

                x[i][m-8][k]=1.16071429*b[k][3]*2*s;
            }
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
//操作：     原址第三遍列PTV
//前置条件： x: 指向存放直流系数三维数组首地址,m:列长度；n:行宽度
//后置条件： 数据在原址上处理完成
void PTV_Column_3(float ***x,int m,int n)
{
    if(m%16==0)
    {
        PTV_4k_Column_3(x,m,n);
    }
    else if(m%16==8)
    {
        PTV_4k_2_Column_3(x,m,n);
    }
    else
    {
        ODD_PTV_Column_3(x,m,n);
    }
}
void IPTV_4k_Column_3(float ***x,int m,int n)
{
    float a[4];
    //float b[n][6];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 6);
    for(i=0;i<96;i+=8)
    {
        for(k=0;k<n;k+=4)
        {
            b[k][4]=(x[i][0][k]+x[i][4][k])*s;
            b[k][5]=(x[i][0][k]-x[i][4][k])*s;
            b[k][0]=(x[i][8][k]+x[i][12][k])*s;
            b[k][1]=(x[i][8][k]-x[i][12][k])*s;
            b[k][2]=(x[i][16][k]+x[i][20][k])*s;
            b[k][3]=(x[i][16][k]-x[i][20][k])*s;

            a[0]=b[k][4]+0.125*b[k][5];
            a[1]=b[k][0]-0.125*b[k][2];
            a[2]=-0.125*b[k][4]+b[k][5];
            a[3]=b[k][1]+0.125*b[k][3];

            x[i][0][k]=a[0]-0.125*a[1];
            x[i][4][k]=a[2]+0.125*a[3];
            x[i][8][k]=0.125*a[0]+a[1];
            x[i][12][k]=-0.125*a[2]+a[3];

        }
        for(j=16;j<m-16;j+=16)
        {
            for(k=0;k<n;k+=4)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=(x[i][j+8][k]+x[i][j+12][k])*s;
                b[k][1]=(x[i][j+8][k]-x[i][j+12][k])*s;
                b[k][2]=(x[i][j+16][k]+x[i][j+20][k])*s;
                b[k][3]=(x[i][j+16][k]-x[i][j+20][k])*s;

                a[1]=b[k][0]-0.125*b[k][2];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][j][k]=a[0]-0.125*a[1];
                x[i][j+4][k]=a[2]+0.125*a[3];
                x[i][j+8][k]=0.125*a[0]+a[1];
                x[i][j+12][k]=-0.125*a[2]+a[3];
            }
        }
        for(k=0;k<n;k+=4)
        {
            a[0]=0.125*b[k][0]+b[k][2];
            a[2]=-0.125*b[k][1]+b[k][3];

            b[k][0]=(x[i][m-8][k]+x[i][m-4][k])*s;
            b[k][1]=(x[i][m-8][k]-x[i][m-4][k])*s;

            a[1]=b[k][0]-0.125*b[k][1];
            a[3]=0.125*b[k][0]+b[k][1];

            x[i][m-16][k]=a[0]-0.125*a[1];
            x[i][m-12][k]=a[2]+0.125*a[3];
            x[i][m-8][k]=0.125*a[0]+a[1];
            x[i][m-4][k]=-0.125*a[2]+a[3];
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void IPTV_4k_2_Column_3(float ***x,int m,int n)
{
    float a[4];
    //float b[n][4];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 4);
    for(i=0;i<96;i+=8)
    {
        for(k=0;k<n;k+=4)
        {
            b[k][0]=(x[i][0][k]+x[i][4][k])*s;
            b[k][1]=(x[i][0][k]-x[i][4][k])*s;
            b[k][2]=(x[i][8][k]+x[i][12][k])*s;
            b[k][3]=(x[i][8][k]-x[i][12][k])*s;

            a[0]=b[k][0]-0.125*b[k][2];
            a[1]=b[k][1]+0.125*b[k][3];

            x[i][0][k]=a[0]+0.125*a[1];
            x[i][4][k]=-0.125*a[0]+a[1];
        }
        for(j=8;j<m-16;j+=16)
        {
            for(k=0;k<n;k+=4)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=(x[i][j+8][k]+x[i][j+12][k])*s;
                b[k][1]=(x[i][j+8][k]-x[i][j+12][k])*s;
                b[k][2]=(x[i][j+16][k]+x[i][j+20][k])*s;
                b[k][3]=(x[i][j+16][k]-x[i][j+20][k])*s;

                a[1]=b[k][0]-0.125*b[k][2];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][j][k]=a[0]-0.125*a[1];
                x[i][j+4][k]=a[2]+0.125*a[3];
                x[i][j+8][k]=0.125*a[0]+a[1];
                x[i][j+12][k]=-0.125*a[2]+a[3];
            }
        }
        for(k=0;k<n;k+=4)
        {
            a[0]=0.125*b[k][0]+b[k][2];
            a[2]=-0.125*b[k][1]+b[k][3];

            b[k][0]=(x[i][m-8][k]+x[i][m-4][k])*s;
            b[k][1]=(x[i][m-8][k]-x[i][m-4][k])*s;

            a[1]=b[k][0]-0.125*b[k][1];
            a[3]=0.125*b[k][0]+b[k][1];

            x[i][m-16][k]=a[0]-0.125*a[1];
            x[i][m-12][k]=a[2]+0.125*a[3];
            x[i][m-8][k]=0.125*a[0]+a[1];
            x[i][m-4][k]=-0.125*a[2]+a[3];
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
void ODD_IPTV_Column_3(float ***x,int m,int n)
{
    float a[4];
    //float b[n][6];
	float **b = (float**)malloc(sizeof(float*)*n);
	for (int i = 0; i < n; i++)
		b[i] = (float*)malloc(sizeof(float)* 6);
    m+=4;
    for(i=0;i<96;i+=8)
    {
        if(m%16==0)
        {
            for(k=0; k<n; k+=4)
            {
                b[k][4]=(x[i][0][k]+x[i][4][k])*s;
                b[k][5]=(x[i][0][k]-x[i][4][k])*s;
                b[k][0]=(x[i][8][k]+x[i][12][k])*s;
                b[k][1]=(x[i][8][k]-x[i][12][k])*s;
                b[k][2]=(x[i][16][k]+x[i][20][k])*s;
                b[k][3]=(x[i][16][k]-x[i][20][k])*s;

                a[0]=b[k][4]+0.125*b[k][5];
                a[1]=b[k][0]-0.125*b[k][2];
                a[2]=-0.125*b[k][4]+b[k][5];
                a[3]=b[k][1]+0.125*b[k][3];

                x[i][0][k]=a[0]-0.125*a[1];
                x[i][4][k]=a[2]+0.125*a[3];
                x[i][8][k]=0.125*a[0]+a[1];
                x[i][12][k]=-0.125*a[2]+a[3];
            }
            for(j=16; j<m-16; j+=16)
            {
                for(k=0; k<n; k+=4)
                {
                    a[0]=0.125*b[k][0]+b[k][2];
                    a[2]=-0.125*b[k][1]+b[k][3];

                    b[k][0]=(x[i][j+8][k]+x[i][j+12][k])*s;
                    b[k][1]=(x[i][j+8][k]-x[i][j+12][k])*s;
                    b[k][2]=(x[i][j+16][k]+x[i][j+20][k])*s;
                    b[k][3]=(x[i][j+16][k]-x[i][j+20][k])*s;

                    a[1]=b[k][0]-0.125*b[k][2];
                    a[3]=b[k][1]+0.125*b[k][3];

                    x[i][j][k]=a[0]-0.125*a[1];
                    x[i][j+4][k]=a[2]+0.125*a[3];
                    x[i][j+8][k]=0.125*a[0]+a[1];
                    x[i][j+12][k]=-0.125*a[2]+a[3];
                }
            }
            for(k=0; k<n; k+=4)
            {
                a[0]=0.125*b[k][0]+b[k][2];
                a[2]=-0.125*b[k][1]+b[k][3];

                b[k][0]=b[k][1]=x[i][m-8][k]*s;

                a[1]=b[k][0]-0.125*b[k][1];
                a[3]=0.125*b[k][0]+b[k][1];

                x[i][m-16][k]=a[0]-0.125*a[1];
                x[i][m-12][k]=a[2]+0.125*a[3];
                x[i][m-8][k]=0.125*a[0]+a[1];
            }
        }
        else
        {
            for(k=0; k<n; k+=4)
            {
                b[k][0]=(x[i][0][k]+x[i][4][k])*s;
                b[k][1]=(x[i][0][k]-x[i][4][k])*s;
                b[k][2]=(x[i][8][k]+x[i][12][k])*s;
                b[k][3]=(x[i][8][k]-x[i][12][k])*s;

                a[0]=b[k][0]-0.125*b[k][2];
                a[1]=b[k][1]+0.125*b[k][3];

                x[i][0][k]=a[0]+0.125*a[1];
                x[i][4][k]=-0.125*a[0]+a[1];
            }
            for(j=8; j<m-16; j+=16)
            {
                for(k=0; k<n; k+=4)
                {
                    a[0]=0.125*b[k][0]+b[k][2];
                    a[2]=-0.125*b[k][1]+b[k][3];

                    b[k][0]=(x[i][j+8][k]+x[i][j+12][k])*s;
                    b[k][1]=(x[i][j+8][k]-x[i][j+12][k])*s;
                    b[k][2]=(x[i][j+16][k]+x[i][j+20][k])*s;
                    b[k][3]=(x[i][j+16][k]-x[i][j+20][k])*s;

                    a[1]=b[k][0]-0.125*b[k][2];
                    a[3]=b[k][1]+0.125*b[k][3];

                    x[i][j][k]=a[0]-0.125*a[1];
                    x[i][j+4][k]=a[2]+0.125*a[3];
                    x[i][j+8][k]=0.125*a[0]+a[1];
                    x[i][j+12][k]=-0.125*a[2]+a[3];
                }
             }
             for(k=0;k<n;k+=4)
             {
                 a[0]=0.125*b[k][0]+b[k][2];
                 a[2]=-0.125*b[k][1]+b[k][3];

                 b[k][0]=b[k][1]=x[i][m-8][k]*s;

                 a[1]=b[k][0]-0.125*b[k][1];
                 a[3]=0.125*b[k][0]+b[k][1];

                 x[i][m-16][k]=a[0]-0.125*a[1];
                 x[i][m-12][k]=a[2]+0.125*a[3];
                 x[i][m-8][k]=0.125*a[0]+a[1];
             }
        }
    }
	for (int i = 0; i < n; i++)
		free(b[i]);
	free(b);
}
//操作：     原址第三遍列IPTV
//前置条件： x: 指向存放直流系数三维数组首地址,m:列长度；n:行宽度
//后置条件： 数据在原址上处理完成
void IPTV_Column_3(float ***x,int m,int n)
{
    if(m%16==0)
    {
        IPTV_4k_Column_3(x,m,n);
    }
    else if(m%16==8)
    {
        IPTV_4k_2_Column_3(x,m,n);
    }
    else
    {
        ODD_IPTV_Column_3(x,m,n);
    }
}
void PTV_Row_Size(int *x,int N)
{
     x[0]=N/8;
     if(x[0]%2==1)
     {
         x[1]=(x[0]+1)*0.5;
     }
     else
     {
         x[1]=x[0]*0.5;
     }

     if(x[1]%2==1)
     {
         x[2]=(x[1]+1)*0.5;
     }
     else
     {
         x[2]=x[1]*0.5;
     }
}
void PTV_Column_Size(int *x,int m)
{
    m/=8;
    x[0]=m;
    if(m%2==1)
    {
        m+=1;
        x[1]=m;
    }
    else
    {
        x[1]=m;
    }
    if(m%4==2)
    {
        m+=2;
        x[2]=m;
    }
    else
    {
        x[2]=m;
    }
}

unsigned char *** forward_transform(int N, int M) //N是宽 M是高
{
	unsigned char *** ImgData;
	extern float *** VideoData;
	extern float *** PTVData;
	FILE *fp;
	int m, n;
	int num[3];
	int num2[3];
	float t1[1920];

	PTV_Column_Size(num2, M);
	PTV_Row_Size(num, N);
	m = M / 8;
	n = N / 8;

	printf("变换准备工作开始:\n");
	ImgData = readYUV("BirdsInCage_1920x1080_60_8bit_422.yuv", M, N, 1, 96, 422);
	if (ImgData){
		for (i = 0; i < 96; i++)
		{
			for (j = 0; j < M; j++)
			{
				for (k = 0; k < N; k++)
				{
					VideoData[i][j][k] = (float)ImgData[i][j][k];
				}
			}
		}
	}
	else{
		printf("数据读取失败，或者数据为空！\n");
		return 0;
	}

	/*内存释放*/
	//for (int i = 0; i < 96; i++){
	//	for (int j = 0; j < M; j++){
	//		free(ImgData[i][j]);
	//	}
	//	free(ImgData[i]);
	//}
	//free(ImgData);

	for (i = 0; i<1920; i++)
	{
		t1[i] = i;
	}
	Even_row_scwp2(t1, 1024);
	Even_row_iscwp2(t1, 1024);

	printf("正变换开始\n");
	if (N % 16 == 0)
	{
		for (i = 0; i<96; i++)
		{
			for (j = 0; j<M; j++)
			{
				Even_row_scwp2(&VideoData[i][j][0], N);
			}
		}
	}
	else
	{
		for (i = 0; i<96; i++)
		{
			for (j = 0; j<M; j++)
			{
				Odd_row_scwp2(&VideoData[i][j][0], N);
			}
		}
	}

	if (M % 16 == 0)
	{
		EVEN_SCWP_column_Method2(VideoData, M, N);
	}
	else
	{
		ODD_SCWP_column_Method2(VideoData, M, N);
	}

	EVEN_SCWP4_Method2(VideoData, M, N);

	Haar_DWT(VideoData, 96, M, N);

	for (i = 0; i<96; i++)
	{
		for (j = 0; j<m; j++)
		{
			PTV_Row_1(&VideoData[i][j * 8][0], &PTVData[i][j][0], N);
		}
	}


	PTV_Column_1(PTVData, num2[0], n);

	for (i = 0; i<96; i++)
	{
		for (j = 0; j<m; j += 2)
		{
			PTV_Row_2(&PTVData[i][j][0], num[1]);
		}
	}
	PTV_Column_2(PTVData, num2[1], n);

	for (i = 0; i<96; i += 8)
	{
		for (j = 0; j<m; j += 4)
		{
			PTV_Row_3(&PTVData[i][j][0], num[2]);
		}
	}


	PTV_Column_3(PTVData, num2[2], n);


	printf("正变换结束\n");
	return ImgData;
}

void inverse_transformation(int N, int M)
{
	printf("逆变换开始\n");
	int m, n;
	int num[3];
	int num2[3];
	extern float *** reVideoData;
	extern float *** rePTVData;

	PTV_Column_Size(num2, M);
	PTV_Row_Size(num, N);
	m = M / 8;
	n = N / 8;

	IPTV_Column_3(rePTVData, num2[2], n);

	for (i = 0; i<96; i += 8)
	{
		for (j = 0; j<m; j += 4)
		{
			IPTV_Row_3(&rePTVData[i][j][0], num[2]);
		}
	}

	IPTV_Column_2(rePTVData, num2[1], n);

	for (i = 0; i<96; i++)
	{
		for (j = 0; j<m; j += 2)
		{
			IPTV_Row_2(&rePTVData[i][j][0], num[1]);
		}
	}

	IPTV_Column_1(rePTVData, num2[0], n);

	for (i = 0; i<96; i++)
	{
		for (j = 0; j<m; j++)
		{
			IPTV_Row_1(&rePTVData[i][j][0], &reVideoData[i][j * 8][0], num[0]);
		}
	}

	Haar_IDWT(reVideoData, 96, M, N);

	i_EVEN_SCWP4_Method2(reVideoData, M, N);

	if (N % 16 == 0)
	{
		for (i = 0; i<96; i++)
		{
			for (j = 0; j<M; j++)
			{
				Even_row_iscwp2(&reVideoData[i][j][0], N);
			}

		}
	}
	else
	{
		for (i = 0; i<96; i++)
		{
			for (j = 0; j<M; j++)
			{
				Odd_row_iscwp2(&reVideoData[i][j][0], N);
			}

		}
	}
	if (M % 16 == 0)
	{
		i_EVEN_SCWP_column_Method2(reVideoData, M, N);
	}
	else
	{
		i_ODD_SCWP_column_Method2(reVideoData, M, N);

	}
	printf("逆变换结束\n");

	return;
}
